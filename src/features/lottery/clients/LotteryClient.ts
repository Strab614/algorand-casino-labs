/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from "@algorandfoundation/algokit-utils";
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from "@algorandfoundation/algokit-utils/types/app";
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from "@algorandfoundation/algokit-utils/types/app-client";
import type { AppSpec } from "@algorandfoundation/algokit-utils/types/app-spec";
import type {
  SendTransactionResult,
  TransactionToSign,
  SendTransactionFrom,
  SendTransactionParams,
} from "@algorandfoundation/algokit-utils/types/transaction";
import type { ABIResult, TransactionWithSigner } from "algosdk";
import {
  Algodv2,
  OnApplicationComplete,
  Transaction,
  AtomicTransactionComposer,
  modelsv2,
} from "algosdk";
export const APP_SPEC: any = {
  hints: {
    "setManager(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getManager()address": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getMbrCost(uint16[5][])uint64": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getWinningNumbers()uint16[5]": {
      call_config: {
        no_op: "CALL",
      },
    },
    "createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void": {
      call_config: {
        no_op: "CREATE",
      },
    },
    "deleteApplication()void": {
      call_config: {
        delete_application: "CALL",
      },
    },
    "bootstrap()void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "addPrizePool(axfer)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "setEntry(axfer,uint16[5][])void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "draw()void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getRefund(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "payWinner(address,uint64)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "userCleanup(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
  },
  bare_call_config: {
    no_op: "NEVER",
    opt_in: "NEVER",
    close_out: "NEVER",
    update_application: "NEVER",
    delete_application: "NEVER",
  },
  schema: {
    local: {
      declared: {},
      reserved: {},
    },
    global: {
      declared: {
        _manager: {
          type: "bytes",
          key: "ma",
        },
        _beaconAppId: {
          type: "uint64",
          key: "ba",
        },
        _commitmentRound: {
          type: "uint64",
          key: "dr",
        },
        _randomBytes: {
          type: "bytes",
          key: "ra",
        },
        _pcgState: {
          type: "uint64",
          key: "ps",
        },
        name: {
          type: "bytes",
          key: "na",
        },
        asa: {
          type: "uint64",
          key: "as",
        },
        ticketPrice: {
          type: "uint64",
          key: "tp",
        },
        feePercent: {
          type: "uint64",
          key: "fp",
        },
        endRound: {
          type: "uint64",
          key: "er",
        },
        ticketsSold: {
          type: "uint64",
          key: "ts",
        },
        totalFees: {
          type: "uint64",
          key: "tf",
        },
        prizePool: {
          type: "uint64",
          key: "pp",
        },
        winningNumbers: {
          type: "bytes",
          key: "wn",
        },
      },
      reserved: {},
    },
  },
  state: {
    global: {
      num_byte_slices: 4,
      num_uints: 10,
    },
    local: {
      num_byte_slices: 0,
      num_uints: 0,
    },
  },
  source: {
    approval:
      "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjk2LjIKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNhbGxfRGVsZXRlQXBwbGljYXRpb24gKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBzZXRNYW5hZ2VyKGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX3NldE1hbmFnZXI6CgkvLyBtYW5hZ2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKG1hbmFnZXIpIGZvciBzZXRNYW5hZ2VyIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIHNldE1hbmFnZXIoYWRkcmVzcyl2b2lkCgljYWxsc3ViIHNldE1hbmFnZXIKCWludCAxCglyZXR1cm4KCi8vIHNldE1hbmFnZXIobWFuYWdlcjogQWRkcmVzcyk6IHZvaWQKLy8KLy8KLy8gQ2hhbmdlcyB3aGljaCBhZGRyZXNzIGNhbiBtYW5hZ2UgdGhpcyBjb250cmFjdAovLwovLyBAcGFyYW0gbWFuYWdlciB0aGUgQWRkcmVzcyB0aGF0IHdpbGwgYmUgYWJsZSB0byBtYW5hZ2UgdGhlIGNvbnRyYWN0CnNldE1hbmFnZXI6Cglwcm90byAxIDAKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL01hbmFnZWFibGUuYWxnby50czoxNgoJLy8gdGhpcy5fbWFuYWdlci5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg2ZDYxIC8vICJtYSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6ICppZjBfZW5kCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTWFuYWdlYWJsZS5hbGdvLnRzOjE3CgkvLyB2ZXJpZnlUeG4odGhpcy50eG4sIHsKCS8vICAgICAgICAgc2VuZGVyOiB0aGlzLl9tYW5hZ2VyLnZhbHVlLAoJLy8gICAgICAgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCXR4biBTZW5kZXIKCWJ5dGUgMHg2ZDYxIC8vICJtYSIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5fbWFuYWdlci52YWx1ZSJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTWFuYWdlYWJsZS5hbGdvLnRzOjIxCgkvLyBhc3NlcnQodGhpcy5fbWFuYWdlci52YWx1ZSAhPT0gbWFuYWdlcikKCWJ5dGUgMHg2ZDYxIC8vICJtYSIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gbWFuYWdlcjogQWRkcmVzcwoJIT0KCWFzc2VydAoKKmlmMF9lbmQ6CgkvLyBjb250cmFjdHMvTWFuYWdlYWJsZS5hbGdvLnRzOjI0CgkvLyB0aGlzLl9tYW5hZ2VyLnZhbHVlID0gbWFuYWdlcgoJYnl0ZSAweDZkNjEgLy8gIm1hIgoJZnJhbWVfZGlnIC0xIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldE1hbmFnZXIoKWFkZHJlc3MKKmFiaV9yb3V0ZV9nZXRNYW5hZ2VyOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldE1hbmFnZXIoKWFkZHJlc3MKCWNhbGxzdWIgZ2V0TWFuYWdlcgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldE1hbmFnZXIoKTogQWRkcmVzcwovLwovLwovLyBSZXR1cm5zIHRoZSBjdXJyZW50IG1hbmFnZXIKLy8KLy8gQHJldHVybnMgVGhlIGN1cnJlbnQgbWFuYWdlcnMgQWRkcmVzcwpnZXRNYW5hZ2VyOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL01hbmFnZWFibGUuYWxnby50czozNQoJLy8gcmV0dXJuIHRoaXMuX21hbmFnZXIudmFsdWU7CglieXRlIDB4NmQ2MSAvLyAibWEiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBpc01hbmFnZXIoKTogYm9vbGVhbgppc01hbmFnZXI6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTWFuYWdlYWJsZS5hbGdvLnRzOjM5CgkvLyByZXR1cm4gdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLmdldE1hbmFnZXIoKTsKCXR4biBTZW5kZXIKCWNhbGxzdWIgZ2V0TWFuYWdlcgoJPT0KCXJldHN1YgoKLy8gY29tbWl0VG9Sb3VuZChhcHBJZDogQXBwSUQsIHJvdW5kOiB1aW50NjQpOiB2b2lkCmNvbW1pdFRvUm91bmQ6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvUmFuZG9tbmVzcy5hbGdvLnRzOjE5CgkvLyB0aGlzLl9iZWFjb25BcHBJZC52YWx1ZSA9IGFwcElkCglieXRlIDB4NjI2MSAvLyAiYmEiCglmcmFtZV9kaWcgLTEgLy8gYXBwSWQ6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9SYW5kb21uZXNzLmFsZ28udHM6MjAKCS8vIHRoaXMuX2NvbW1pdG1lbnRSb3VuZC52YWx1ZSA9IHJvdW5kCglieXRlIDB4NjQ3MiAvLyAiZHIiCglmcmFtZV9kaWcgLTIgLy8gcm91bmQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gZ2V0UmFuZG9tQnl0ZXMoKTogYnl0ZXMKLy8KLy8gR2V0IHJhbmRvbW5lc3MgZnJvbSB0aGUgb3JhY2xlIG9yIGJ5IGhhc2hpbmcgZXhpc3RpbmcgcmFuZG9tbmVzcwpnZXRSYW5kb21CeXRlczoKCXByb3RvIDAgMQoKCS8vICppZjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvUmFuZG9tbmVzcy5hbGdvLnRzOjI1CgkvLyB0aGlzLl9yYW5kb21CeXRlcy5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3MjYxIC8vICJyYSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6ICppZjFfZWxzZQoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL1JhbmRvbW5lc3MuYWxnby50czoyNgoJLy8gdGhpcy5fcmFuZG9tQnl0ZXMudmFsdWUgPSBzaGEyNTYodGhpcy5fcmFuZG9tQnl0ZXMudmFsdWUpIGFzIGJ5dGVzCglieXRlIDB4NzI2MSAvLyAicmEiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglzaGEyNTYKCWFwcF9nbG9iYWxfcHV0CgliICppZjFfZW5kCgoqaWYxX2Vsc2U6CgkvLyBjb250cmFjdHMvUmFuZG9tbmVzcy5hbGdvLnRzOjI4CgkvLyB0aGlzLl9yYW5kb21CeXRlcy52YWx1ZSA9IHNlbmRNZXRob2RDYWxsPFt1aW50NjQsIGJ5dGVzXSwgYnl0ZXM+KHsKCS8vICAgICAgICAgbmFtZTogJ211c3RfZ2V0JywKCS8vICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMuX2NvbW1pdG1lbnRSb3VuZC52YWx1ZSwgJyddLCAvLyB3ZSBhcmUgcGFzc2luZyB0aGUgcm91bmQgYXMgZGF0YSB0byBiZSBoYXNoZWQKCS8vICAgICAgICAgYXBwbGljYXRpb25JRDogdGhpcy5fYmVhY29uQXBwSWQudmFsdWUsCgkvLyAgICAgICAgIGZlZTogMCwKCS8vICAgICAgICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRpb24uTm9PcCwKCS8vICAgICAgIH0pCglieXRlIDB4NzI2MSAvLyAicmEiCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJtdXN0X2dldCh1aW50NjQsYnl0ZVtdKWJ5dGVbXSIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL1JhbmRvbW5lc3MuYWxnby50czozMAoJLy8gbWV0aG9kQXJnczogW3RoaXMuX2NvbW1pdG1lbnRSb3VuZC52YWx1ZSwgJyddCglieXRlIDB4NjQ3MiAvLyAiZHIiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGUgMHgwMDAwCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9SYW5kb21uZXNzLmFsZ28udHM6MzEKCS8vIGFwcGxpY2F0aW9uSUQ6IHRoaXMuX2JlYWNvbkFwcElkLnZhbHVlCglieXRlIDB4NjI2MSAvLyAiYmEiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL1JhbmRvbW5lc3MuYWxnby50czozMgoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBjb250cmFjdHMvUmFuZG9tbmVzcy5hbGdvLnRzOjMzCgkvLyBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5Ob09wCglpbnQgMCAvLyBOb09wCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50IDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJZXh0cmFjdCAyIDAKCWFwcF9nbG9iYWxfcHV0CgoqaWYxX2VuZDoKCS8vIGNvbnRyYWN0cy9SYW5kb21uZXNzLmFsZ28udHM6MzcKCS8vIHJldHVybiB0aGlzLl9yYW5kb21CeXRlcy52YWx1ZTsKCWJ5dGUgMHg3MjYxIC8vICJyYSIKCWFwcF9nbG9iYWxfZ2V0CglyZXRzdWIKCi8vIHJhbmRvbW5lc3NSZWFkeSgpOiBib29sZWFuCnJhbmRvbW5lc3NSZWFkeToKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9SYW5kb21uZXNzLmFsZ28udHM6NDMKCS8vIHJldHVybiBnbG9iYWxzLnJvdW5kID49IHRoaXMuX2NvbW1pdG1lbnRSb3VuZC52YWx1ZTsKCWdsb2JhbCBSb3VuZAoJYnl0ZSAweDY0NzIgLy8gImRyIgoJYXBwX2dsb2JhbF9nZXQKCT49CglyZXRzdWIKCi8vIHJhbmRvbW5lc3NFeHBpcmVkKCk6IGJvb2xlYW4KcmFuZG9tbmVzc0V4cGlyZWQ6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvUmFuZG9tbmVzcy5hbGdvLnRzOjQ4CgkvLyByZXR1cm4gZ2xvYmFscy5yb3VuZCA+PSB0aGlzLl9jb21taXRtZW50Um91bmQudmFsdWUgKyBPUkFDTEVfTUFYX1JPVU5EUzsKCWdsb2JhbCBSb3VuZAoJYnl0ZSAweDY0NzIgLy8gImRyIgoJYXBwX2dsb2JhbF9nZXQKCWludCAxNTEyCgkrCgk+PQoJcmV0c3ViCgovLyBfX3R3b3NDb21wbGVtZW50KHZhbHVlOiB1aW50NjQpOiB1aW50NjQKX190d29zQ29tcGxlbWVudDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjYKCS8vIGFkZHdSZXN1bHQgPSBhZGR3KH52YWx1ZSwgMSkKCWZyYW1lX2RpZyAtMSAvLyB2YWx1ZTogdWludDY0Cgl+CglpbnQgMQoJYWRkdwoJZnJhbWVfYnVyeSAwIC8vIGFkZHdSZXN1bHQgbG93OiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyBhZGR3UmVzdWx0IGhpZ2g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NwoJLy8gcmV0dXJuIGFkZHdSZXN1bHQubG93OwoJZnJhbWVfZGlnIDAgLy8gYWRkd1Jlc3VsdCBsb3c6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gX19tYXNrVG9VaW50MzIodmFsdWU6IHVpbnQ2NCk6IHVpbnQ2NApfX21hc2tUb1VpbnQzMjoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MTEKCS8vIHJldHVybiB2YWx1ZSAmIDQyOTQ5NjcyOTU7CglmcmFtZV9kaWcgLTEgLy8gdmFsdWU6IHVpbnQ2NAoJaW50IDQyOTQ5NjcyOTUKCSYKCXJldHN1YgoKLy8gX19wY2czMlN0ZXAoc3RhdGU6IHVpbnQ2NCwgaW5jcjogdWludDY0KTogdWludDY0Cl9fcGNnMzJTdGVwOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MTUKCS8vIG11bHdSZXN1bHQgPSBtdWx3KHN0YXRlLCBVaW50PDY0PignNjM2NDEzNjIyMzg0Njc5MzAwNScpKQoJZnJhbWVfZGlnIC0xIC8vIHN0YXRlOiB1aW50NjQKCWludCA2MzY0MTM2MjIzODQ2NzkzMDA1CgltdWx3CglmcmFtZV9idXJ5IDAgLy8gbXVsd1Jlc3VsdCBsb3c6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIG11bHdSZXN1bHQgaGlnaDogdWludDY0CgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czoxNgoJLy8gYWRkd1Jlc3VsdCA9IGFkZHcobXVsd1Jlc3VsdC5sb3csIGluY3IpCglmcmFtZV9kaWcgMCAvLyBtdWx3UmVzdWx0IGxvdzogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gaW5jcjogdWludDY0CglhZGR3CglmcmFtZV9idXJ5IDIgLy8gYWRkd1Jlc3VsdCBsb3c6IHVpbnQ2NAoJZnJhbWVfYnVyeSAzIC8vIGFkZHdSZXN1bHQgaGlnaDogdWludDY0CgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czoxOAoJLy8gcmV0dXJuIGFkZHdSZXN1bHQubG93OwoJZnJhbWVfZGlnIDIgLy8gYWRkd1Jlc3VsdCBsb3c6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gX19wY2czMlJvdGF0aW9uKHZhbHVlOiB1aW50NjQsIHJvdDogdWludDY0KTogdWludDY0Cl9fcGNnMzJSb3RhdGlvbjoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MjIKCS8vIHJldHVybiAodmFsdWUgPj4gcm90KSB8IHRoaXMuX19tYXNrVG9VaW50MzIodmFsdWUgPDwgKHRoaXMuX190d29zQ29tcGxlbWVudChyb3QpICYgMzEpKTsKCWZyYW1lX2RpZyAtMSAvLyB2YWx1ZTogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gcm90OiB1aW50NjQKCXNocgoJZnJhbWVfZGlnIC0xIC8vIHZhbHVlOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyByb3Q6IHVpbnQ2NAoJY2FsbHN1YiBfX3R3b3NDb21wbGVtZW50CglpbnQgMzEKCSYKCXNobAoJY2FsbHN1YiBfX21hc2tUb1VpbnQzMgoJfAoJcmV0c3ViCgovLyBfX3BjZzMyT3V0cHV0KHN0YXRlOiB1aW50NjQpOiB1aW50NjQKX19wY2czMk91dHB1dDoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MjYKCS8vIHJldHVybiB0aGlzLl9fcGNnMzJSb3RhdGlvbih0aGlzLl9fbWFza1RvVWludDMyKCgoc3RhdGUgPj4gMTgpIF4gc3RhdGUpID4+IDI3KSwgc3RhdGUgPj4gNTkpOwoJZnJhbWVfZGlnIC0xIC8vIHN0YXRlOiB1aW50NjQKCWludCA1OQoJc2hyCglmcmFtZV9kaWcgLTEgLy8gc3RhdGU6IHVpbnQ2NAoJaW50IDE4CglzaHIKCWZyYW1lX2RpZyAtMSAvLyBzdGF0ZTogdWludDY0CgleCglpbnQgMjcKCXNocgoJY2FsbHN1YiBfX21hc2tUb1VpbnQzMgoJY2FsbHN1YiBfX3BjZzMyUm90YXRpb24KCXJldHN1YgoKLy8gX19wY2czMlJhbmRvbShzdGF0ZTogdWludDY0KTogW3VpbnQ2NCwgdWludDY0XQpfX3BjZzMyUmFuZG9tOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czozMAoJLy8gcmV0dXJuIFt0aGlzLl9fcGNnMzJTdGVwKHN0YXRlLCBVaW50PDY0PignMTQ0MjY5NTA0MDg4ODk2MzQwNycpKSwgdGhpcy5fX3BjZzMyT3V0cHV0KHN0YXRlKV07CglpbnQgMTQ0MjY5NTA0MDg4ODk2MzQwNwoJZnJhbWVfZGlnIC0xIC8vIHN0YXRlOiB1aW50NjQKCWNhbGxzdWIgX19wY2czMlN0ZXAKCWl0b2IKCWZyYW1lX2RpZyAtMSAvLyBzdGF0ZTogdWludDY0CgljYWxsc3ViIF9fcGNnMzJPdXRwdXQKCWl0b2IKCWNvbmNhdAoJcmV0c3ViCgovLyBfX3BjZzMySW5pdChpbml0aWFsU3RhdGU6IHVpbnQ2NCwgaW5jcjogdWludDY0KTogdWludDY0Cl9fcGNnMzJJbml0OgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MzQKCS8vIHN0YXRlID0gdGhpcy5fX3BjZzMyU3RlcCgwLCBpbmNyKQoJZnJhbWVfZGlnIC0yIC8vIGluY3I6IHVpbnQ2NAoJaW50IDAKCWNhbGxzdWIgX19wY2czMlN0ZXAKCWZyYW1lX2J1cnkgMCAvLyBzdGF0ZTogdWludDY0CgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czozNQoJLy8gYWRkd1Jlc3VsdCA9IGFkZHcoc3RhdGUsIGluaXRpYWxTdGF0ZSkKCWZyYW1lX2RpZyAwIC8vIHN0YXRlOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBpbml0aWFsU3RhdGU6IHVpbnQ2NAoJYWRkdwoJZnJhbWVfYnVyeSAxIC8vIGFkZHdSZXN1bHQgbG93OiB1aW50NjQKCWZyYW1lX2J1cnkgMiAvLyBhZGR3UmVzdWx0IGhpZ2g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6MzcKCS8vIHJldHVybiB0aGlzLl9fcGNnMzJTdGVwKGFkZHdSZXN1bHQubG93LCBpbmNyKTsKCWZyYW1lX2RpZyAtMiAvLyBpbmNyOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGFkZHdSZXN1bHQgbG93OiB1aW50NjQKCWNhbGxzdWIgX19wY2czMlN0ZXAKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIHBjZzMySW5pdChpbml0aWFsU3RhdGU6IHVpbnQ2NCk6IHVpbnQ2NApwY2czMkluaXQ6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjQxCgkvLyByZXR1cm4gdGhpcy5fX3BjZzMySW5pdChpbml0aWFsU3RhdGUsIFVpbnQ8NjQ+KCcxNDQyNjk1MDQwODg4OTYzNDA3JykpOwoJaW50IDE0NDI2OTUwNDA4ODg5NjM0MDcKCWZyYW1lX2RpZyAtMSAvLyBpbml0aWFsU3RhdGU6IHVpbnQ2NAoJY2FsbHN1YiBfX3BjZzMySW5pdAoJcmV0c3ViCgovLyBwY2czMlJhbmRvbShzdGF0ZTogdWludDY0LCBiaXRTaXplOiB1aW50NjQsIGxvd2VyQm91bmQ6IHVpbnQ2NCwgdXBwZXJCb3VuZDogdWludDY0LCBsZW5ndGg6IHVpbnQ2NCk6IFt1aW50NjQsIGJ5dGVzXQpwY2czMlJhbmRvbToKCXByb3RvIDUgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDgKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjUxCgkvLyByZXN1bHQ6IGJ5dGVzID0gJycKCWJ5dGUgMHggLy8gIiIKCWZyYW1lX2J1cnkgMCAvLyByZXN1bHQ6IGJ5dGVzCgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo1NQoJLy8gYXNzZXJ0KGxlbmd0aCA8IDY1NTM2KQoJZnJhbWVfZGlnIC01IC8vIGxlbmd0aDogdWludDY0CglpbnQgNjU1MzYKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NTcKCS8vIGFzc2VydChiaXRTaXplID09PSA4IHx8IGJpdFNpemUgPT09IDE2IHx8IGJpdFNpemUgPT09IDMyKQoJZnJhbWVfZGlnIC0yIC8vIGJpdFNpemU6IHVpbnQ2NAoJaW50IDgKCT09CglkdXAKCWJueiAqc2tpcF9vcjAKCWZyYW1lX2RpZyAtMiAvLyBiaXRTaXplOiB1aW50NjQKCWludCAxNgoJPT0KCXx8Cgoqc2tpcF9vcjA6CglkdXAKCWJueiAqc2tpcF9vcjEKCWZyYW1lX2RpZyAtMiAvLyBiaXRTaXplOiB1aW50NjQKCWludCAzMgoJPT0KCXx8Cgoqc2tpcF9vcjE6Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjU4CgkvLyBieXRlU2l6ZSA9IGJpdFNpemUgPj4gMwoJZnJhbWVfZGlnIC0yIC8vIGJpdFNpemU6IHVpbnQ2NAoJaW50IDMKCXNocgoJZnJhbWVfYnVyeSAzIC8vIGJ5dGVTaXplOiB1aW50NjQKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjU5CgkvLyB0cnVuY2F0ZVN0YXJ0Q2FjaGVkID0gOCAtIGJ5dGVTaXplCglpbnQgOAoJZnJhbWVfZGlnIDMgLy8gYnl0ZVNpemU6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA0IC8vIHRydW5jYXRlU3RhcnRDYWNoZWQ6IHVpbnQ2NAoKCS8vICppZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjYxCgkvLyBsb3dlckJvdW5kID09PSAwICYmIHVwcGVyQm91bmQgPT09IDAKCWZyYW1lX2RpZyAtMyAvLyBsb3dlckJvdW5kOiB1aW50NjQKCWludCAwCgk9PQoJZHVwCglieiAqc2tpcF9hbmQwCglmcmFtZV9kaWcgLTQgLy8gdXBwZXJCb3VuZDogdWludDY0CglpbnQgMAoJPT0KCSYmCgoqc2tpcF9hbmQwOgoJYnogKmlmMl9lbHNlCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjYyCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSA9IGkgKyAxKQoJaW50IDAKCWZyYW1lX2J1cnkgNSAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NjIKCS8vIGkgPCBsZW5ndGgKCWZyYW1lX2RpZyA1IC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIC01IC8vIGxlbmd0aDogdWludDY0Cgk8CglieiAqZm9yXzBfZW5kCgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo2MwoJLy8gcHJuID0gdGhpcy5fX3BjZzMyUmFuZG9tKHN0YXRlKQoJZnJhbWVfZGlnIC0xIC8vIHN0YXRlOiB1aW50NjQKCWNhbGxzdWIgX19wY2czMlJhbmRvbQoJZnJhbWVfYnVyeSA2IC8vIHBybjogKHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo2NAoJLy8gc3RhdGUgPSBwcm5bMF0KCWZyYW1lX2RpZyA2IC8vIHBybjogKHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfYnVyeSAtMSAvLyBzdGF0ZTogdWludDY0CgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo2NQoJLy8gcmVzdWx0ICs9IGV4dHJhY3QzKGl0b2IocHJuWzFdKSwgdHJ1bmNhdGVTdGFydENhY2hlZCwgYnl0ZVNpemUpCglmcmFtZV9kaWcgMCAvLyByZXN1bHQ6IGJ5dGVzCglmcmFtZV9kaWcgNiAvLyBwcm46ICh1aW50NjQsdWludDY0KQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2RpZyA0IC8vIHRydW5jYXRlU3RhcnRDYWNoZWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gYnl0ZVNpemU6IHVpbnQ2NAoJZXh0cmFjdDMKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHJlc3VsdDogYnl0ZXMKCipmb3JfMF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NjIKCS8vIGkgPSBpICsgMQoJZnJhbWVfZGlnIDUgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSA1IC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzAKCipmb3JfMF9lbmQ6CgliICppZjJfZW5kCgoqaWYyX2Vsc2U6CgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo2OAoJLy8gdXBwZXJCb3VuZCAhPT0gMAoJZnJhbWVfZGlnIC00IC8vIHVwcGVyQm91bmQ6IHVpbnQ2NAoJaW50IDAKCSE9CglieiAqaWYzX2Vsc2UKCgkvLyAqaWYzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NjkKCS8vIGFzc2VydCh1cHBlckJvdW5kID4gMSkKCWZyYW1lX2RpZyAtNCAvLyB1cHBlckJvdW5kOiB1aW50NjQKCWludCAxCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjcwCgkvLyBhc3NlcnQodXBwZXJCb3VuZCA8IDEgPDwgYml0U2l6ZSkKCWZyYW1lX2RpZyAtNCAvLyB1cHBlckJvdW5kOiB1aW50NjQKCWludCAxCglmcmFtZV9kaWcgLTIgLy8gYml0U2l6ZTogdWludDY0CglzaGwKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6NzIKCS8vIGFzc2VydChsb3dlckJvdW5kIDwgdXBwZXJCb3VuZCAtIDEpCglmcmFtZV9kaWcgLTMgLy8gbG93ZXJCb3VuZDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gdXBwZXJCb3VuZDogdWludDY0CglpbnQgMQoJLQoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo3NAoJLy8gYWJzb2x1dGVCb3VuZCA9IHVwcGVyQm91bmQgLSBsb3dlckJvdW5kCglmcmFtZV9kaWcgLTQgLy8gdXBwZXJCb3VuZDogdWludDY0CglmcmFtZV9kaWcgLTMgLy8gbG93ZXJCb3VuZDogdWludDY0CgktCglmcmFtZV9idXJ5IDEgLy8gYWJzb2x1dGVCb3VuZDogdWludDY0CgliICppZjNfZW5kCgoqaWYzX2Vsc2U6CgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjc2CgkvLyBhc3NlcnQobG93ZXJCb3VuZCA8ICgxIDw8IGJpdFNpemUpIC0gMSkKCWZyYW1lX2RpZyAtMyAvLyBsb3dlckJvdW5kOiB1aW50NjQKCWludCAxCglmcmFtZV9kaWcgLTIgLy8gYml0U2l6ZTogdWludDY0CglzaGwKCWludCAxCgktCgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjc4CgkvLyBhYnNvbHV0ZUJvdW5kID0gKDEgPDwgYml0U2l6ZSkgLSBsb3dlckJvdW5kCglpbnQgMQoJZnJhbWVfZGlnIC0yIC8vIGJpdFNpemU6IHVpbnQ2NAoJc2hsCglmcmFtZV9kaWcgLTMgLy8gbG93ZXJCb3VuZDogdWludDY0CgktCglmcmFtZV9idXJ5IDEgLy8gYWJzb2x1dGVCb3VuZDogdWludDY0CgoqaWYzX2VuZDoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6ODEKCS8vIHRocmVzaG9sZCA9IHRoaXMuX19tYXNrVG9VaW50MzIodGhpcy5fX3R3b3NDb21wbGVtZW50KGFic29sdXRlQm91bmQpKSAlIGFic29sdXRlQm91bmQKCWZyYW1lX2RpZyAxIC8vIGFic29sdXRlQm91bmQ6IHVpbnQ2NAoJY2FsbHN1YiBfX3R3b3NDb21wbGVtZW50CgljYWxsc3ViIF9fbWFza1RvVWludDMyCglmcmFtZV9kaWcgMSAvLyBhYnNvbHV0ZUJvdW5kOiB1aW50NjQKCSUKCWZyYW1lX2J1cnkgMiAvLyB0aHJlc2hvbGQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6ODMKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpCglpbnQgMAoJZnJhbWVfYnVyeSA3IC8vIGk6IHVpbnQ2NAoKKmZvcl8xOgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo4MwoJLy8gaSA8IGxlbmd0aAoJZnJhbWVfZGlnIDcgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTUgLy8gbGVuZ3RoOiB1aW50NjQKCTwKCWJ6ICpmb3JfMV9lbmQKCip3aGlsZV8wOgoKKndoaWxlXzBfY29udGludWU6CgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjg2CgkvLyB0cnVlCglpbnQgMQoJYnogKndoaWxlXzBfZW5kCgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo4NwoJLy8gcHJuID0gdGhpcy5fX3BjZzMyUmFuZG9tKHN0YXRlKQoJZnJhbWVfZGlnIC0xIC8vIHN0YXRlOiB1aW50NjQKCWNhbGxzdWIgX19wY2czMlJhbmRvbQoJZnJhbWVfYnVyeSA4IC8vIHBybjogW3VpbnQ2NCwgdWludDY0XQoKCS8vIGNvbnRyYWN0cy9wY2cvbGliLXBjZzMyLXRzLmFsZ28udHM6ODgKCS8vIHN0YXRlID0gcHJuWzBdCglmcmFtZV9kaWcgOCAvLyBwcm46IFt1aW50NjQsIHVpbnQ2NF0KCWV4dHJhY3QgMCA4CglidG9pCglmcmFtZV9idXJ5IC0xIC8vIHN0YXRlOiB1aW50NjQKCgkvLyAqaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo4OQoJLy8gcHJuWzFdID49IHRocmVzaG9sZAoJZnJhbWVfZGlnIDggLy8gcHJuOiBbdWludDY0LCB1aW50NjRdCglleHRyYWN0IDggOAoJYnRvaQoJZnJhbWVfZGlnIDIgLy8gdGhyZXNob2xkOiB1aW50NjQKCT49CglieiAqaWY0X2VuZAoKCS8vICppZjRfY29uc2VxdWVudAoJYiAqd2hpbGVfMF9lbmQKCippZjRfZW5kOgoJYiAqd2hpbGVfMAoKKndoaWxlXzBfZW5kOgoJLy8gY29udHJhY3RzL3BjZy9saWItcGNnMzItdHMuYWxnby50czo5NAoJLy8gcmVzdWx0ICs9IGV4dHJhY3QzKGl0b2IoKHByblsxXSAlIGFic29sdXRlQm91bmQpICsgbG93ZXJCb3VuZCksIHRydW5jYXRlU3RhcnRDYWNoZWQsIGJ5dGVTaXplKQoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiBieXRlcwoJZnJhbWVfZGlnIDggLy8gcHJuOiBbdWludDY0LCB1aW50NjRdCglleHRyYWN0IDggOAoJYnRvaQoJZnJhbWVfZGlnIDEgLy8gYWJzb2x1dGVCb3VuZDogdWludDY0CgklCglmcmFtZV9kaWcgLTMgLy8gbG93ZXJCb3VuZDogdWludDY0CgkrCglpdG9iCglmcmFtZV9kaWcgNCAvLyB0cnVuY2F0ZVN0YXJ0Q2FjaGVkOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGJ5dGVTaXplOiB1aW50NjQKCWV4dHJhY3QzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyByZXN1bHQ6IGJ5dGVzCgoqZm9yXzFfY29udGludWU6CgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjgzCgkvLyBpID0gaSArIDEKCWZyYW1lX2RpZyA3IC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgNyAvLyBpOiB1aW50NjQKCWIgKmZvcl8xCgoqZm9yXzFfZW5kOgoKKmlmMl9lbmQ6CgkvLyBjb250cmFjdHMvcGNnL2xpYi1wY2czMi10cy5hbGdvLnRzOjk4CgkvLyByZXR1cm4gW3N0YXRlLCByZXN1bHRdOwoJYnl0ZSAweCAvLyBpbml0aWFsIGhlYWQKCWJ5dGUgMHggLy8gaW5pdGlhbCB0YWlsCglieXRlIDB4MDAwYSAvLyBpbml0aWFsIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gc3RhdGU6IHVpbnQ2NAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDAgLy8gcmVzdWx0OiBieXRlcwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiA4CglyZXRzdWIKCi8vIHNldFBjZ1NlZWQobjogdWludDY0KTogdm9pZApzZXRQY2dTZWVkOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL1BjZy5hbGdvLnRzOjEwCgkvLyB0aGlzLl9wY2dTdGF0ZS52YWx1ZSA9IG4KCWJ5dGUgMHg3MDczIC8vICJwcyIKCWZyYW1lX2RpZyAtMSAvLyBuOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdldFBjZ1JhbmRvbShtaW46IHVpbnQ2NCwgbWF4OiB1aW50NjQsIGxlbmd0aDogdWludDY0KTogdWludDMyW10KZ2V0UGNnUmFuZG9tOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvUGNnLmFsZ28udHM6MTQKCS8vIHIgPSB0aGlzLnBjZzMyUmFuZG9tKHRoaXMuX3BjZ1N0YXRlLnZhbHVlLCAzMiwgbWluLCBtYXgsIGxlbmd0aCkKCWZyYW1lX2RpZyAtMyAvLyBsZW5ndGg6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIG1heDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gbWluOiB1aW50NjQKCWludCAzMgoJYnl0ZSAweDcwNzMgLy8gInBzIgoJYXBwX2dsb2JhbF9nZXQKCWNhbGxzdWIgcGNnMzJSYW5kb20KCWZyYW1lX2J1cnkgMCAvLyByOiAodWludDY0LGJ5dGVbXSkKCgkvLyBjb250cmFjdHMvUGNnLmFsZ28udHM6MTYKCS8vIHRoaXMuX3BjZ1N0YXRlLnZhbHVlID0gclswXQoJYnl0ZSAweDcwNzMgLy8gInBzIgoJZnJhbWVfZGlnIDAgLy8gcjogKHVpbnQ2NCxieXRlW10pCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL1BjZy5hbGdvLnRzOjE4CgkvLyByZXR1cm4gY2FzdEJ5dGVzPHVpbnQzMltdPihyWzFdKTsKCWZyYW1lX2RpZyAwIC8vIHI6ICh1aW50NjQsYnl0ZVtdKQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCA4Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cgl1bmNvdmVyIDIKCWV4dHJhY3RfdWludDE2CglkdXAgLy8gZHVwbGljYXRlIHN0YXJ0IG9mIGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWV4dHJhY3RfdWludDE2IC8vIGdldCBudW1iZXIgb2YgZWxlbWVudHMKCWludCAxIC8vIGdldCB0eXBlIGxlbmd0aAoJKiAvLyBtdWx0aXBseSBieSB0eXBlIGxlbmd0aAoJaW50IDIKCSsgLy8gYWRkIHR3byBmb3IgbGVuZ3RoCglleHRyYWN0MwoJZXh0cmFjdCAyIDAKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gZ2V0TWJyQ29zdCh1aW50MTZbNV1bXSl1aW50NjQKKmFiaV9yb3V0ZV9nZXRNYnJDb3N0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBlbnRyeTogdWludDE2WzVdW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBnZXRNYnJDb3N0KHVpbnQxNls1XVtdKXVpbnQ2NAoJY2FsbHN1YiBnZXRNYnJDb3N0CglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TWJyQ29zdChlbnRyeTogTG90dGVyeU51bWJlcnNbXSk6IHVpbnQ2NAovLwovLyBHZXRzIE1CUiBjb3N0IGZvciB0aGUgYm94Ci8vIEByZXR1cm5zIE1CUiBjb3N0IGZvciB0aGUgYm94CmdldE1ickNvc3Q6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo5MgoJLy8gQk9YX0NSRUFURV9DT1NUOiB1aW50NjQgPSAyNTAwCglpbnQgMjUwMAoJZnJhbWVfYnVyeSAwIC8vIEJPWF9DUkVBVEVfQ09TVDogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo5MwoJLy8gQk9YX0JZVEVfQ09TVDogdWludDY0ID0gNDAwCglpbnQgNDAwCglmcmFtZV9idXJ5IDEgLy8gQk9YX0JZVEVfQ09TVDogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo5NQoJLy8ga2V5U2l6ZSA9IGxlbihnbG9iYWxzLnplcm9BZGRyZXNzKQoJaW50IDMyCglmcmFtZV9idXJ5IDIgLy8ga2V5U2l6ZTogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo5NgoJLy8gYm94U2l6ZSA9IGxlbihlbnRyeSkgKyA4CglmcmFtZV9kaWcgLTEgLy8gZW50cnk6IExvdHRlcnlOdW1iZXJzW10KCWxlbgoJaW50IDgKCSsKCWZyYW1lX2J1cnkgMyAvLyBib3hTaXplOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjk4CgkvLyByZXR1cm4gQk9YX0NSRUFURV9DT1NUICsgQk9YX0JZVEVfQ09TVCAqIChrZXlTaXplICsgYm94U2l6ZSk7CglmcmFtZV9kaWcgMCAvLyBCT1hfQ1JFQVRFX0NPU1Q6IHVpbnQ2NAoJaW50IDQwMCAvLyBCT1hfQllURV9DT1NUOiB1aW50NjQKCWludCAzMiAvLyBrZXlTaXplOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGJveFNpemU6IHVpbnQ2NAoJKwoJKgoJKwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gZ2V0V2lubmluZ051bWJlcnMoKXVpbnQxNls1XQoqYWJpX3JvdXRlX2dldFdpbm5pbmdOdW1iZXJzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldFdpbm5pbmdOdW1iZXJzKCl1aW50MTZbNV0KCWNhbGxzdWIgZ2V0V2lubmluZ051bWJlcnMKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXRXaW5uaW5nTnVtYmVycygpOiBMb3R0ZXJ5TnVtYmVycwovLwovLwovLyBSZXR1cm5zIHRoZSB3aW5uaW5nIGxvdHRlcnkgbnVtYmVycyAoY2FuIHVzZSBhbGdvZCBzaW11bGF0ZSBpbnN0ZWFkIG9mIGluZGV4ZXIpCi8vCi8vIEByZXR1cm5zIFRoZSB3aW5uaW5nIGxvdHRlcnkgbnVtYmVycyBhcyBhIGBMb3R0ZXJ5TnVtYmVyc2AgdHlwZQpnZXRXaW5uaW5nTnVtYmVyczoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTA5CgkvLyByZXR1cm4gdGhpcy53aW5uaW5nTnVtYmVycy52YWx1ZTsKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWFwcF9nbG9iYWxfZ2V0CglyZXRzdWIKCi8vIGRlbGV0ZUJveEFuZFJlZnVuZChhZGRyZXNzOiBBZGRyZXNzKTogdm9pZAovLwovLwovLyBEZWxldGUgYSBnaXZlbiBib3ggYW5kIHNlbmQgdXNlciBiYWNrIHRoZSBjb3N0IChtaW51cyAwLjAwMiBhbGdvcykgIGQKLy8gQHJldHVybnMgdm9pZCwgdGhyb3dzIG9uIGVycm9yCmRlbGV0ZUJveEFuZFJlZnVuZDoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxMjAKCS8vIGFtb3VudDogdWludDY0ID0gdGhpcy5nZXRNYnJDb3N0KHRoaXMudXNlckVudHJ5KGFkZHJlc3MpLnZhbHVlKQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMudXNlckVudHJ5KGFkZHJlc3MpLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCgljYWxsc3ViIGdldE1ickNvc3QKCWZyYW1lX2J1cnkgMCAvLyBhbW91bnQ6IHVpbnQ2NAoKCS8vICppZjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjEyNAoJLy8gdGhpcy50eG4uc2VuZGVyICE9PSBhZGRyZXNzCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJIT0KCWJ6ICppZjVfZW5kCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjEyNQoJLy8gYW1vdW50IC09IDIwMDAKCWZyYW1lX2RpZyAwIC8vIGFtb3VudDogdWludDY0CglpbnQgMjAwMAoJLQoJZnJhbWVfYnVyeSAwIC8vIGFtb3VudDogdWludDY0CgoqaWY1X2VuZDoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTI5CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICByZWNlaXZlcjogYWRkcmVzcywKCS8vICAgICAgIHNlbmRlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgbm90ZTogJ2JveCBtYnIgcmVmdW5kJywKCS8vICAgICAgIGZlZTogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTMwCgkvLyByZWNlaXZlcjogYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjEzMQoJLy8gc2VuZGVyOiB0aGlzLmFwcC5hZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjEzMgoJLy8gYW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAwIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTMzCgkvLyBub3RlOiAnYm94IG1iciByZWZ1bmQnCglieXRlIDB4NjI2Zjc4MjA2ZDYyNzIyMDcyNjU2Njc1NmU2NCAvLyAiYm94IG1iciByZWZ1bmQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjEzNAoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxMzgKCS8vIHRoaXMudXNlckVudHJ5KGFkZHJlc3MpLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJYm94X2RlbAoJcmV0c3ViCgovLyB2YWxpZGF0ZU51bWJlcnMobnVtYmVyczogTG90dGVyeU51bWJlcnMpOiB2b2lkCi8vCi8vCi8vIFZhbGlkYXRlIGEgYExvdHRlcnlOdW1iZXJzYCBvYmplY3QgKG11c3QgaGF2ZSB2YWx1ZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYW5kIGFsbCBiZSB1bmlxdWUpCi8vIEBwYXJhbSBudW1iZXJzIGBMb3R0ZXJ5TnVtYmVycyBvYmplY3QgdG8gYmUgY2hlY2tlZAovLyBAdGhyb3dzIGFzc2VydCBjYWxsZWQgaWYgbnVtYmVycyBhcmUgb3V0c2lkZSB0aGUgTUlOX05VTUJFUiBhbmQgTUFYX05VTUJFUiB2YWx1ZXMgb3IgYXJlIG5vdCB1bmlxdWUKLy8gQHJldHVybnMgdm9pZCwgdGhyb3dzIG9uIGVycm9yCnZhbGlkYXRlTnVtYmVyczoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjE1MgoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSArPSAxKQoJaW50IDAKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMjoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTUyCgkvLyBpIDwgbnVtYmVycy5sZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDUKCTwKCWJ6ICpmb3JfMl9lbmQKCgkvLyAqaWY2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNTQKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgNzAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnQgNzAwCgk8CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNTUKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjZfZW5kOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNTgKCS8vIG4gPSBudW1iZXJzW2ldCglmcmFtZV9kaWcgLTEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDIKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50IDIKCWV4dHJhY3QzCglidG9pCglmcmFtZV9idXJ5IDAgLy8gbjogdWludDE2CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNjAKCS8vIGFzc2VydHMobiA+PSBNSU5fTlVNQkVSLCBuIDw9IE1BWF9OVU1CRVIpCglmcmFtZV9kaWcgMCAvLyBuOiB1aW50MTYKCWludCAxCgk+PQoKCS8vIGFzc2VydHMgZmFpbGVkOiBhc3NlcnRzKG4gPj0gTUlOX05VTUJFUiwgbiA8PSBNQVhfTlVNQkVSKQoJYXNzZXJ0CglmcmFtZV9kaWcgMCAvLyBuOiB1aW50MTYKCWludCA1MAoJPD0KCgkvLyBhc3NlcnRzIGZhaWxlZDogYXNzZXJ0cyhuID49IE1JTl9OVU1CRVIsIG4gPD0gTUFYX05VTUJFUikKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTYyCgkvLyBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlcnMubGVuZ3RoOyBqICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSAyIC8vIGo6IHVpbnQ2NAoKKmZvcl8zOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNjIKCS8vIGogPCBudW1iZXJzLmxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gajogdWludDY0CglpbnQgNQoJPAoJYnogKmZvcl8zX2VuZAoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjE2NAoJLy8gZ2xvYmFscy5vcGNvZGVCdWRnZXQgPCA3MDAKCWdsb2JhbCBPcGNvZGVCdWRnZXQKCWludCA3MDAKCTwKCWJ6ICppZjdfZW5kCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjE2NQoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludCAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZSBiNjQgQ29FQiAvLyAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnQgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmN19lbmQ6CgkvLyAqaWY4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoxNjgKCS8vIGkgPCBqCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAyIC8vIGo6IHVpbnQ2NAoJPAoJYnogKmlmOF9lbmQKCgkvLyAqaWY4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTcwCgkvLyBhc3NlcnQobnVtYmVyc1tqXSAhPT0gbiwgJ251bWJlcnMgbXVzdCBiZSB1bmlxdWUnKQoJZnJhbWVfZGlnIC0xIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglmcmFtZV9kaWcgMiAvLyBqOiB1aW50NjQKCWludCAyCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCAyCglleHRyYWN0MwoJYnRvaQoJZnJhbWVfZGlnIDAgLy8gbjogdWludDE2CgkhPQoKCS8vIG51bWJlcnMgbXVzdCBiZSB1bmlxdWUKCWFzc2VydAoKKmlmOF9lbmQ6CgoqZm9yXzNfY29udGludWU6CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjE2MgoJLy8gaiArPSAxCglmcmFtZV9kaWcgMiAvLyBqOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDIgLy8gajogdWludDY0CgliICpmb3JfMwoKKmZvcl8zX2VuZDoKCipmb3JfMl9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTUyCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgKmZvcl8yCgoqZm9yXzJfZW5kOgoJcmV0c3ViCgovLyB2YWxpZGF0ZUVudHJ5KGVudHJpZXM6IExvdHRlcnlOdW1iZXJzW10pOiB2b2lkCi8vCi8vCi8vIFZhbGlkYXRlIGFuIGFycmF5IG9mIExvdHRlcnlOdW1iZXJzIHR5cGUKLy8gQHBhcmFtIGVudHJpZXMgTG90dGVyeU51bWJlcnMgYXJyYXkgdG8gYmUgY2hlY2tlZAovLyBAdGhyb3dzIGlmIGFueSBvZiB0aGUgTG90dGVyeU51bWJlcnMgb2JqZWN0cyBhcmUgaW52YWxpZAovLyBAcmV0dXJucyB2b2lkCnZhbGlkYXRlRW50cnk6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTg1CgkvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkKCWludCAwCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoqZm9yXzQ6CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjE4NQoJLy8gaSA8IGVudHJpZXMubGVuZ3RoCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBlbnRyaWVzOiBMb3R0ZXJ5TnVtYmVyc1tdCglsZW4KCWludCAxMAoJLwoJPAoJYnogKmZvcl80X2VuZAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTg2CgkvLyB0aGlzLnZhbGlkYXRlTnVtYmVycyhlbnRyaWVzW2ldKQoJZnJhbWVfZGlnIC0xIC8vIGVudHJpZXM6IExvdHRlcnlOdW1iZXJzW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMCAvLyBpbml0aWFsIG9mZnNldAoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnQgMTAKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50IDEwCglleHRyYWN0MwoJY2FsbHN1YiB2YWxpZGF0ZU51bWJlcnMKCipmb3JfNF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MTg1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCWIgKmZvcl80CgoqZm9yXzRfZW5kOgoJcmV0c3ViCgovLyBjaGVja1VuaXF1ZShudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycywgaTogdWludDY0LCBuOiB1aW50MTYpOiBib29sZWFuCi8vCi8vCi8vIENoZWNrcyBMb3R0ZXJ5TnVtYmVycyBmb3IgZHVwbGljYXRlcwovLyBAcGFyYW0gbnVtYmVycyBMb3R0ZXJ5TnVtYmVycyBvYmplY3QgKGNhbiBwYWRkZWQgd2l0aCB6ZXJvcywgdHJlYXRlZCBhcyBubyB2YWx1ZSkKLy8gQHBhcmFtIGkgaG93IG1hbnkgbm9uLXZhbHVlIHZhbHVlcyBkb2VzIHRoZSBMb3R0ZXJ5TnVtYmVycyBvYmplY3QgaGF2ZT8KLy8gQHBhcmFtIG4gdGhlIG51bWJlciB0byBjaGVjayBmb3IgZHVwbGljYXRlcwovLyBAcmV0dXJucyBib29sZWFuLCByZXR1cm5zIGZhbHNlIGlmIG5vdCB1bmlxdWUKY2hlY2tVbmlxdWU6Cglwcm90byAzIDEKCgkvLyAqaWY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyMDEKCS8vIGkgPT09IDEgJiYgbnVtYmVyc1swXSA9PT0gKG4gYXMgdWludDE2KQoJZnJhbWVfZGlnIC0yIC8vIGk6IHVpbnQ2NAoJaW50IDEKCT09CglkdXAKCWJ6ICpza2lwX2FuZDEKCWZyYW1lX2RpZyAtMSAvLyBudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycwoJZXh0cmFjdCAwIDIKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBuOiB1aW50MTYKCT09CgkmJgoKKnNraXBfYW5kMToKCWJ6ICppZjlfZW5kCgoJLy8gKmlmOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjIwMgoJLy8gcmV0dXJuIGZhbHNlOwoJaW50IDAKCXJldHN1YgoKKmlmOV9lbmQ6CgkvLyAqaWYxMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjA0CgkvLyBpID09PSAyICYmIChudW1iZXJzWzBdID09PSAobiBhcyB1aW50MTYpIHx8IG51bWJlcnNbMV0gPT09IChuIGFzIHVpbnQxNikpCglmcmFtZV9kaWcgLTIgLy8gaTogdWludDY0CglpbnQgMgoJPT0KCWR1cAoJYnogKnNraXBfYW5kMgoJZnJhbWVfZGlnIC0xIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglleHRyYWN0IDAgMgoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIG46IHVpbnQxNgoJPT0KCWR1cAoJYm56ICpza2lwX29yMgoJZnJhbWVfZGlnIC0xIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglleHRyYWN0IDIgMgoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIG46IHVpbnQxNgoJPT0KCXx8Cgoqc2tpcF9vcjI6CgkmJgoKKnNraXBfYW5kMjoKCWJ6ICppZjEwX2VuZAoKCS8vICppZjEwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjA1CgkvLyByZXR1cm4gZmFsc2U7CglpbnQgMAoJcmV0c3ViCgoqaWYxMF9lbmQ6CgkvLyAqaWYxMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjA3CgkvLyBpID09PSAzICYmIChudW1iZXJzWzBdID09PSAobiBhcyB1aW50MTYpIHx8IG51bWJlcnNbMV0gPT09IChuIGFzIHVpbnQxNikgfHwgbnVtYmVyc1syXSA9PT0gKG4gYXMgdWludDE2KSkKCWZyYW1lX2RpZyAtMiAvLyBpOiB1aW50NjQKCWludCAzCgk9PQoJZHVwCglieiAqc2tpcF9hbmQzCglmcmFtZV9kaWcgLTEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWV4dHJhY3QgMCAyCglidG9pCglmcmFtZV9kaWcgLTMgLy8gbjogdWludDE2Cgk9PQoJZHVwCglibnogKnNraXBfb3IzCglmcmFtZV9kaWcgLTEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWV4dHJhY3QgMiAyCglidG9pCglmcmFtZV9kaWcgLTMgLy8gbjogdWludDE2Cgk9PQoJfHwKCipza2lwX29yMzoKCWR1cAoJYm56ICpza2lwX29yNAoJZnJhbWVfZGlnIC0xIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglleHRyYWN0IDQgMgoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIG46IHVpbnQxNgoJPT0KCXx8Cgoqc2tpcF9vcjQ6CgkmJgoKKnNraXBfYW5kMzoKCWJ6ICppZjExX2VuZAoKCS8vICppZjExX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjA4CgkvLyByZXR1cm4gZmFsc2U7CglpbnQgMAoJcmV0c3ViCgoqaWYxMV9lbmQ6CgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjExCgkvLyBpID09PSA0ICYmCgkvLyAgICAgICAobnVtYmVyc1swXSA9PT0gKG4gYXMgdWludDE2KSB8fAoJLy8gICAgICAgICBudW1iZXJzWzFdID09PSAobiBhcyB1aW50MTYpIHx8CgkvLyAgICAgICAgIG51bWJlcnNbMl0gPT09IChuIGFzIHVpbnQxNikgfHwKCS8vICAgICAgICAgbnVtYmVyc1szXSA9PT0gKG4gYXMgdWludDE2KSkKCWZyYW1lX2RpZyAtMiAvLyBpOiB1aW50NjQKCWludCA0Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQ0CglmcmFtZV9kaWcgLTEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWV4dHJhY3QgMCAyCglidG9pCglmcmFtZV9kaWcgLTMgLy8gbjogdWludDE2Cgk9PQoJZHVwCglibnogKnNraXBfb3I1CglmcmFtZV9kaWcgLTEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWV4dHJhY3QgMiAyCglidG9pCglmcmFtZV9kaWcgLTMgLy8gbjogdWludDE2Cgk9PQoJfHwKCipza2lwX29yNToKCWR1cAoJYm56ICpza2lwX29yNgoJZnJhbWVfZGlnIC0xIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglleHRyYWN0IDQgMgoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIG46IHVpbnQxNgoJPT0KCXx8Cgoqc2tpcF9vcjY6CglkdXAKCWJueiAqc2tpcF9vcjcKCWZyYW1lX2RpZyAtMSAvLyBudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycwoJZXh0cmFjdCA2IDIKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBuOiB1aW50MTYKCT09Cgl8fAoKKnNraXBfb3I3OgoJJiYKCipza2lwX2FuZDQ6CglieiAqaWYxMl9lbmQKCgkvLyAqaWYxMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjIxNwoJLy8gcmV0dXJuIGZhbHNlOwoJaW50IDAKCXJldHN1YgoKKmlmMTJfZW5kOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyMjAKCS8vIHJldHVybiB0cnVlOwoJaW50IDEKCXJldHN1YgoKLy8gY3JlYXRlQXBwbGljYXRpb24oc3RyaW5nLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGZlZVBlcmNlbnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwoJYnRvaQoKCS8vIHRpY2tldFByaWNlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyBkcmF3Um91bmQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIGVuZFJvdW5kOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBiZWFjb25BcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gYXNhOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBuYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24obmFtZTogc3RyaW5nLCBhc2E6IEFzc2V0SUQsIGJlYWNvbkFwcElkOiBBcHBJRCwgZW5kUm91bmQ6IHVpbnQ2NCwgZHJhd1JvdW5kOiB1aW50NjQsIHRpY2tldFByaWNlOiB1aW50NjQsIGZlZVBlcmNlbnQ6IHVpbnQ2NCk6IHZvaWQKLy8KLy8KLy8gY3JlYXRlIHRoZSBhcHBsaWNhdGlvbgovLwovLyBAcGFyYW0gbmFtZSB0aGUgTmFtZSBvZiB0aGUgbG90dGVyeQovLyBAcGFyYW0gYXNhIHRoZSBBc3NldCB3ZSBhY2NlcHQgYXMgcGF5bWVudAovLyBAcGFyYW0gYmVhY29uQXBwSWQgQXBwSUQgb2YgdGhlIHJhbmRvbW5lc3MgYmVhY29uCi8vIEBwYXJhbSBlbmRSb3VuZCB0aGUgcm91bmQgZnJvbSB3aGVuIHRoZSBsb3R0ZXJ5IHdpbGwgbm8gbG9uZ2VyIGFsbG93IGVudHJpZXMKLy8gQHBhcmFtIGRyYXdSb3VuZCB0aGUgcm91bmQgZnJvbSB3aGVuIHdlIGNhbiBkcmF3IHRoZSBsb3R0ZXJ5Ci8vIEBwYXJhbSB0aWNrZXRQcmljZSBob3cgbXVjaCBkb2VzIGEgdGlja2V0IGNvc3QKLy8gQHBhcmFtIGZlZVBlcmNlbnQgd2hhdCBwZXJjZW50IG9mIHRpY2tldFByaWNlIHdpbGwgd2UgdGFrZSBhcyBmZWVzCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gNyAwCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyNDUKCS8vIGFzc2VydChkcmF3Um91bmQgPiBlbmRSb3VuZCwgJ2RyYXdSb3VuZCBpcyBhZnRlciBlbmRSb3VuZCcpCglmcmFtZV9kaWcgLTUgLy8gZHJhd1JvdW5kOiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyBlbmRSb3VuZDogdWludDY0Cgk+CgoJLy8gZHJhd1JvdW5kIGlzIGFmdGVyIGVuZFJvdW5kCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI0OQoJLy8gdGhpcy5zZXRNYW5hZ2VyKGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCWNhbGxzdWIgc2V0TWFuYWdlcgoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjUxCgkvLyB0aGlzLmNvbW1pdFRvUm91bmQoYmVhY29uQXBwSWQsIGRyYXdSb3VuZCkKCWZyYW1lX2RpZyAtNSAvLyBkcmF3Um91bmQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGJlYWNvbkFwcElkOiBBcHBJRAoJY2FsbHN1YiBjb21taXRUb1JvdW5kCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyNTQKCS8vIHRoaXMubmFtZS52YWx1ZSA9IG5hbWUKCWJ5dGUgMHg2ZTYxIC8vICJuYSIKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjU1CgkvLyB0aGlzLmFzYS52YWx1ZSA9IGFzYQoJYnl0ZSAweDYxNzMgLy8gImFzIgoJZnJhbWVfZGlnIC0yIC8vIGFzYTogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI1NgoJLy8gdGhpcy50aWNrZXRQcmljZS52YWx1ZSA9IHRpY2tldFByaWNlCglieXRlIDB4NzQ3MCAvLyAidHAiCglmcmFtZV9kaWcgLTYgLy8gdGlja2V0UHJpY2U6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI1NwoJLy8gdGhpcy5mZWVQZXJjZW50LnZhbHVlID0gZmVlUGVyY2VudAoJYnl0ZSAweDY2NzAgLy8gImZwIgoJZnJhbWVfZGlnIC03IC8vIGZlZVBlcmNlbnQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI1OAoJLy8gdGhpcy5lbmRSb3VuZC52YWx1ZSA9IGVuZFJvdW5kCglieXRlIDB4NjU3MiAvLyAiZXIiCglmcmFtZV9kaWcgLTQgLy8gZW5kUm91bmQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI2MQoJLy8gdGhpcy50aWNrZXRzU29sZC52YWx1ZSA9IDAKCWJ5dGUgMHg3NDczIC8vICJ0cyIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjYyCgkvLyB0aGlzLnRvdGFsRmVlcy52YWx1ZSA9IDAKCWJ5dGUgMHg3NDY2IC8vICJ0ZiIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjYzCgkvLyB0aGlzLnByaXplUG9vbC52YWx1ZSA9IDAKCWJ5dGUgMHg3MDcwIC8vICJwcCIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBkZWxldGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2RlbGV0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBkZWxldGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBkZWxldGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKTogdm9pZAovLwovLwovLyBEZWxldGUgYXBwbGljYXRpb24gYW5kIGNsb3NlT3V0IHRvIG1hbmFnZXIgYWRkcmVzcwpkZWxldGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyNzMKCS8vIGFzc2VydCh0aGlzLmlzTWFuYWdlcigpLCAnY2FsbGVyIGlzIG1hbmFnZXInKQoJY2FsbHN1YiBpc01hbmFnZXIKCgkvLyBjYWxsZXIgaXMgbWFuYWdlcgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyNzYKCS8vIG1hbmFnZXI6IEFkZHJlc3MgPSB0aGlzLmdldE1hbmFnZXIoKQoJY2FsbHN1YiBnZXRNYW5hZ2VyCglmcmFtZV9idXJ5IDAgLy8gbWFuYWdlcjogQWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6Mjc5CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICB4ZmVyQXNzZXQ6IHRoaXMuYXNhLnZhbHVlLAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogbWFuYWdlciwKCS8vICAgICAgIGFzc2V0Q2xvc2VUbzogbWFuYWdlciwKCS8vICAgICAgIGFzc2V0QW1vdW50OiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI4MAoJLy8geGZlckFzc2V0OiB0aGlzLmFzYS52YWx1ZQoJYnl0ZSAweDYxNzMgLy8gImFzIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyODEKCS8vIGFzc2V0UmVjZWl2ZXI6IG1hbmFnZXIKCWZyYW1lX2RpZyAwIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjgyCgkvLyBhc3NldENsb3NlVG86IG1hbmFnZXIKCWZyYW1lX2RpZyAwIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRDbG9zZVRvCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyODMKCS8vIGFzc2V0QW1vdW50OiAwCglpbnQgMAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI4NwoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgcmVjZWl2ZXI6IG1hbmFnZXIsCgkvLyAgICAgICBjbG9zZVJlbWFpbmRlclRvOiBtYW5hZ2VyLAoJLy8gICAgICAgYW1vdW50OiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyODgKCS8vIHJlY2VpdmVyOiBtYW5hZ2VyCglmcmFtZV9kaWcgMCAvLyBtYW5hZ2VyOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czoyODkKCS8vIGNsb3NlUmVtYWluZGVyVG86IG1hbmFnZXIKCWZyYW1lX2RpZyAwIC8vIG1hbmFnZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MjkwCgkvLyBhbW91bnQ6IDAKCWludCAwCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjI5NAoJLy8gdGhpcy5EZWxldGVFdmVudC5sb2coeyBmZWVzOiB0aGlzLnRvdGFsRmVlcy52YWx1ZSwgcHJpemVQb29sOiB0aGlzLnByaXplUG9vbC52YWx1ZSB9KQoJYnl0ZSAweDViNjQwNDFiIC8vIERlbGV0ZUV2ZW50KHVpbnQ2NCx1aW50NjQpCglieXRlIDB4NzQ2NiAvLyAidGYiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJYnl0ZSAweDcwNzAgLy8gInBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gYm9vdHN0cmFwKCl2b2lkCiphYmlfcm91dGVfYm9vdHN0cmFwOgoJLy8gZXhlY3V0ZSBib290c3RyYXAoKXZvaWQKCWNhbGxzdWIgYm9vdHN0cmFwCglpbnQgMQoJcmV0dXJuCgovLyBib290c3RyYXAoKTogdm9pZAovLwovLwovLyBJbml0aWFsaWFzZSB0aGUgYXBwIGFmdGVyIGNyZWF0aW9uCmJvb3RzdHJhcDoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzA0CgkvLyBhc3NlcnQodGhpcy5pc01hbmFnZXIoKSkKCWNhbGxzdWIgaXNNYW5hZ2VyCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMwNwoJLy8gYXNzZXJ0KCF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQodGhpcy5hc2EudmFsdWUpLCAnaXMgbm90IG9wdGVkIGludG8gYXNzZXQnKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWJ5dGUgMHg2MTczIC8vICJhcyIKCWFwcF9nbG9iYWxfZ2V0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXN3YXAKCXBvcAoJIQoKCS8vIGlzIG5vdCBvcHRlZCBpbnRvIGFzc2V0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMwOQoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHhmZXJBc3NldDogdGhpcy5hc2EudmFsdWUsCgkvLyAgICAgICBhc3NldEFtb3VudDogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozMTAKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMxMQoJLy8geGZlckFzc2V0OiB0aGlzLmFzYS52YWx1ZQoJYnl0ZSAweDYxNzMgLy8gImFzIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozMTIKCS8vIGFzc2V0QW1vdW50OiAwCglpbnQgMAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gYWRkUHJpemVQb29sKGF4ZmVyKXZvaWQKKmFiaV9yb3V0ZV9hZGRQcml6ZVBvb2w6CgkvLyBheGZlcjogYXhmZXIKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGF4ZmVyKSBmb3IgYWRkUHJpemVQb29sIG11c3QgYmUgYSBheGZlciB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGRQcml6ZVBvb2woYXhmZXIpdm9pZAoJY2FsbHN1YiBhZGRQcml6ZVBvb2wKCWludCAxCglyZXR1cm4KCi8vIGFkZFByaXplUG9vbChheGZlcjogQXNzZXRUcmFuc2ZlclR4bik6IHZvaWQKLy8KLy8KLy8gQWRkIGFkZGl0aW9uYWwgcHJpemVwb29sIGFzYQovLwovLyBAcGFyYW0gYXhmZXIgdGhlIGFzc2V0IHRyYW5zZmVyIHR4bgphZGRQcml6ZVBvb2w6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMyNAoJLy8gYXNzZXJ0KCF0aGlzLndpbm5pbmdOdW1iZXJzLmV4aXN0cywgJ2xvdHRlcnkgaGFzIG5vdCB5ZXQgYmVlbiBkcmF3bicpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlIDB4Nzc2ZSAvLyAid24iCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCgoJLy8gbG90dGVyeSBoYXMgbm90IHlldCBiZWVuIGRyYXduCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMyNwoJLy8gdmVyaWZ5VHhuKGF4ZmVyLCB7CgkvLyAgICAgICBzZW5kZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHRoaXMuYXNhLnZhbHVlLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsKCS8vICAgICAgICAgZ3JlYXRlclRoYW46IDAsCgkvLyAgICAgICB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMudHhuLnNlbmRlciJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJhc3NldFJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglieXRlIDB4NjE3MyAvLyAiYXMiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJ4ZmVyQXNzZXQiLCJleHBlY3RlZCI6InRoaXMuYXNhLnZhbHVlIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJaW50IDAKCT4KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJhc3NldEFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuIiwiZXhwZWN0ZWQiOiI+MCJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjMzNwoJLy8gdGhpcy5wcml6ZVBvb2wudmFsdWUgKz0gYXhmZXIuYXNzZXRBbW91bnQKCWJ5dGUgMHg3MDcwIC8vICJwcCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CgkrCglieXRlIDB4NzA3MCAvLyAicHAiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzQwCgkvLyB0aGlzLlByaXplUG9vbEFkZGVkRXZlbnQubG9nKHsgYW1vdW50OiBheGZlci5hc3NldEFtb3VudCwgYWRkcmVzczogdGhpcy50eG4uc2VuZGVyLCB0b3RhbDogdGhpcy5wcml6ZVBvb2wudmFsdWUgfSkKCWJ5dGUgMHgzM2EwMzQwNCAvLyBQcml6ZVBvb2xBZGRlZEV2ZW50KHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCXR4biBTZW5kZXIKCWNvbmNhdAoJYnl0ZSAweDcwNzAgLy8gInBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gc2V0RW50cnkoYXhmZXIsdWludDE2WzVdW10pdm9pZAoqYWJpX3JvdXRlX3NldEVudHJ5OgoJLy8gZW50cnk6IHVpbnQxNls1XVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGF4ZmVyOiBheGZlcgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXhmZXIKCT09CgoJLy8gYXJndW1lbnQgMSAoYXhmZXIpIGZvciBzZXRFbnRyeSBtdXN0IGJlIGEgYXhmZXIgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgc2V0RW50cnkoYXhmZXIsdWludDE2WzVdW10pdm9pZAoJY2FsbHN1YiBzZXRFbnRyeQoJaW50IDEKCXJldHVybgoKLy8gc2V0RW50cnkoYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIGVudHJ5OiBMb3R0ZXJ5TnVtYmVyc1tdKTogdm9pZAovLwovLwovLyBBbGxvdyB1c2VyIHRvIHB1cmNoYXNlIHRpY2tldChzKSBvZiB0aGUgbG90dGVyeQovLyBAcGFyYW0gYXhmZXIgQXNzZXRUcmFuc2ZlclR4biB0byBwYXkgZm9yIHRoZSB0aWNrZXRzCi8vIEBwYXJhbSBlbnRyeSBMb3R0ZXJ5TnVtYmVyc1tdIGZvciB0aGUgdXNlcgpzZXRFbnRyeToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM1MQoJLy8gYXNzZXJ0KGdsb2JhbHMucm91bmQgPCB0aGlzLmVuZFJvdW5kLnZhbHVlLCAnY3VycmVudCByb3VuZCBpcyBiZWZvcmUgZW5kUm91bmQnKQoJZ2xvYmFsIFJvdW5kCglieXRlIDB4NjU3MiAvLyAiZXIiCglhcHBfZ2xvYmFsX2dldAoJPAoKCS8vIGN1cnJlbnQgcm91bmQgaXMgYmVmb3JlIGVuZFJvdW5kCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM1MgoJLy8gYXNzZXJ0KCF0aGlzLndpbm5pbmdOdW1iZXJzLmV4aXN0cywgJ2xvdHRlcnkgaGFzIG5vdCBiZWVuIGRyYXduJykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCSEKCgkvLyBsb3R0ZXJ5IGhhcyBub3QgYmVlbiBkcmF3bgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozNTMKCS8vIGFzc2VydChlbnRyeS5sZW5ndGggPD0gTUFYX0VOVFJJRVMsICdlbnRyeSBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIE1BWF9FTlRSSUVTJykKCWZyYW1lX2RpZyAtMiAvLyBlbnRyeTogTG90dGVyeU51bWJlcnNbXQoJbGVuCglpbnQgMTAKCS8KCWludCAxMDAKCTw9CgoJLy8gZW50cnkgaXMgc21hbGxlciBvciBlcXVhbCB0byBNQVhfRU5UUklFUwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozNTUKCS8vIHRpY2tldFByaWNlID0gdGhpcy50aWNrZXRQcmljZS52YWx1ZQoJYnl0ZSAweDc0NzAgLy8gInRwIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMCAvLyB0aWNrZXRQcmljZTogdWludDY0CgoJLy8gKmlmMTNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM1OAoJLy8gdGhpcy51c2VyRW50cnkodGhpcy50eG4uc2VuZGVyKS5leGlzdHMKCXR4biBTZW5kZXIKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogKmlmMTNfZWxzZQoKCS8vICppZjEzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzU5CgkvLyBjdXJyZW50RW50cnlMZW5ndGggPSB0aGlzLnVzZXJFbnRyeSh0aGlzLnR4bi5zZW5kZXIpLnZhbHVlLmxlbmd0aAoJdHhuIFNlbmRlcgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy51c2VyRW50cnkodGhpcy50eG4uc2VuZGVyKS52YWx1ZQoJYXNzZXJ0CglleHRyYWN0IDIgMAoJbGVuCglpbnQgMTAKCS8KCWZyYW1lX2J1cnkgMiAvLyBjdXJyZW50RW50cnlMZW5ndGg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzYxCgkvLyBhc3NlcnQoZW50cnkubGVuZ3RoID4gY3VycmVudEVudHJ5TGVuZ3RoKQoJZnJhbWVfZGlnIC0yIC8vIGVudHJ5OiBMb3R0ZXJ5TnVtYmVyc1tdCglsZW4KCWludCAxMAoJLwoJZnJhbWVfZGlnIDIgLy8gY3VycmVudEVudHJ5TGVuZ3RoOiB1aW50NjQKCT4KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzYzCgkvLyBuID0gZW50cnkubGVuZ3RoIC0gY3VycmVudEVudHJ5TGVuZ3RoCglmcmFtZV9kaWcgLTIgLy8gZW50cnk6IExvdHRlcnlOdW1iZXJzW10KCWxlbgoJaW50IDEwCgkvCglmcmFtZV9kaWcgMiAvLyBjdXJyZW50RW50cnlMZW5ndGg6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxIC8vIG46IHVpbnQ2NAoJYiAqaWYxM19lbmQKCippZjEzX2Vsc2U6CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM2NgoJLy8gbiA9IGVudHJ5Lmxlbmd0aAoJZnJhbWVfZGlnIC0yIC8vIGVudHJ5OiBMb3R0ZXJ5TnVtYmVyc1tdCglsZW4KCWludCAxMAoJLwoJZnJhbWVfYnVyeSAxIC8vIG46IHVpbnQ2NAoKKmlmMTNfZW5kOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozNjkKCS8vIHRvdGFsUHJpY2U6IHVpbnQ2NCA9IG4gKiB0aWNrZXRQcmljZQoJZnJhbWVfZGlnIDEgLy8gbjogdWludDY0CglmcmFtZV9kaWcgMCAvLyB0aWNrZXRQcmljZTogdWludDY0CgkqCglmcmFtZV9idXJ5IDMgLy8gdG90YWxQcmljZTogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozNzEKCS8vIHZlcmlmeVR4bihheGZlciwgewoJLy8gICAgICAgc2VuZGVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiB0aGlzLmFzYS52YWx1ZSwKCS8vICAgICAgIGFzc2V0QW1vdW50OiB0b3RhbFByaWNlLAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMudHhuLnNlbmRlciJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJhc3NldFJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglieXRlIDB4NjE3MyAvLyAiYXMiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJ4ZmVyQXNzZXQiLCJleHBlY3RlZCI6InRoaXMuYXNhLnZhbHVlIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhc3NldEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldEFtb3VudAoJZnJhbWVfZGlnIDMgLy8gdG90YWxQcmljZTogdWludDY0Cgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoiYXhmZXIiLCJmaWVsZCI6ImFzc2V0QW1vdW50IiwiZXhwZWN0ZWQiOiJ0b3RhbFByaWNlIn0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6Mzc4CgkvLyBmZWU6IHVpbnQ2NCA9ICh0b3RhbFByaWNlICogdGhpcy5mZWVQZXJjZW50LnZhbHVlKSAvIDEwMAoJZnJhbWVfZGlnIDMgLy8gdG90YWxQcmljZTogdWludDY0CglieXRlIDB4NjY3MCAvLyAiZnAiCglhcHBfZ2xvYmFsX2dldAoJKgoJaW50IDEwMAoJLwoJZnJhbWVfYnVyeSA0IC8vIGZlZTogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czozODAKCS8vIHRoaXMudG90YWxGZWVzLnZhbHVlICs9IGZlZQoJYnl0ZSAweDc0NjYgLy8gInRmIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyA0IC8vIGZlZTogdWludDY0CgkrCglieXRlIDB4NzQ2NiAvLyAidGYiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6MzgxCgkvLyB0aGlzLnByaXplUG9vbC52YWx1ZSArPSB0b3RhbFByaWNlIC0gZmVlCglieXRlIDB4NzA3MCAvLyAicHAiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDMgLy8gdG90YWxQcmljZTogdWludDY0CglmcmFtZV9kaWcgNCAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJYnl0ZSAweDcwNzAgLy8gInBwIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM4MgoJLy8gdGhpcy50aWNrZXRzU29sZC52YWx1ZSArPSBuCglieXRlIDB4NzQ3MyAvLyAidHMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEgLy8gbjogdWludDY0CgkrCglieXRlIDB4NzQ3MyAvLyAidHMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6Mzg1CgkvLyB0aGlzLnZhbGlkYXRlRW50cnkoZW50cnkpCglmcmFtZV9kaWcgLTIgLy8gZW50cnk6IExvdHRlcnlOdW1iZXJzW10KCWNhbGxzdWIgdmFsaWRhdGVFbnRyeQoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6Mzg4CgkvLyB0aGlzLnVzZXJFbnRyeSh0aGlzLnR4bi5zZW5kZXIpLnZhbHVlID0gZW50cnkKCXR4biBTZW5kZXIKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgLTIgLy8gZW50cnk6IExvdHRlcnlOdW1iZXJzW10KCWR1cAoJbGVuCglpbnQgMTAKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjM5MQoJLy8gdGhpcy5CdXlUaWNrZXRFdmVudC5sb2coeyBhZGRyZXNzOiB0aGlzLnR4bi5zZW5kZXIsIGVudHJpZXM6IGVudHJ5IH0pCglieXRlIDB4OGIyZjM5MjYgLy8gQnV5VGlja2V0RXZlbnQoYWRkcmVzcyx1aW50MTZbNV1bXSkKCWJ5dGUgMHggLy8gaW5pdGlhbCBoZWFkCglieXRlIDB4IC8vIGluaXRpYWwgdGFpbAoJYnl0ZSAweDAwMjIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJdHhuIFNlbmRlcgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0yIC8vIGVudHJ5OiBMb3R0ZXJ5TnVtYmVyc1tdCglkdXAKCWxlbgoJaW50IDEwCgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBkcmF3KCl2b2lkCiphYmlfcm91dGVfZHJhdzoKCS8vIGV4ZWN1dGUgZHJhdygpdm9pZAoJY2FsbHN1YiBkcmF3CglpbnQgMQoJcmV0dXJuCgovLyBkcmF3KCk6IHZvaWQKLy8KLy8KLy8gUGVyZm9ybSB0aGUgbG90dGVyeSBkcmF3IGFuZCBzZXQgYHdpbm5pbmdOdW1iZXJzYApkcmF3OgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDAwCgkvLyBhc3NlcnQodGhpcy5yYW5kb21uZXNzUmVhZHkoKSwgJ3JhbmRvbW5lc3MgY29tbWl0bWVudCByb3VuZCBpcyByZWFjaGVkJykKCWNhbGxzdWIgcmFuZG9tbmVzc1JlYWR5CgoJLy8gcmFuZG9tbmVzcyBjb21taXRtZW50IHJvdW5kIGlzIHJlYWNoZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDAxCgkvLyBhc3NlcnQoIXRoaXMud2lubmluZ051bWJlcnMuZXhpc3RzLCAnbG90dGVyeSBoYXMgbm90IHlldCBiZWVuIGRyYXduJykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCSEKCgkvLyBsb3R0ZXJ5IGhhcyBub3QgeWV0IGJlZW4gZHJhd24KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDAzCgkvLyByYW5kb21CeXRlczogYnl0ZXMgPSB0aGlzLmdldFJhbmRvbUJ5dGVzKCkKCWNhbGxzdWIgZ2V0UmFuZG9tQnl0ZXMKCWZyYW1lX2J1cnkgMCAvLyByYW5kb21CeXRlczogYnl0ZXMKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQwNgoJLy8gdGhpcy5zZXRQY2dTZWVkKGV4dHJhY3RVaW50NjQocmFuZG9tQnl0ZXMsIDApKQoJZnJhbWVfZGlnIDAgLy8gcmFuZG9tQnl0ZXM6IGJ5dGVzCglpbnQgMAoJZXh0cmFjdF91aW50NjQKCWNhbGxzdWIgc2V0UGNnU2VlZAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDA4CgkvLyBudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycyA9IFtdCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAKCWZyYW1lX2J1cnkgMSAvLyBudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycwoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDA5CgkvLyBpID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCip3aGlsZV8xOgoKKndoaWxlXzFfY29udGludWU6CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQxMQoJLy8gaSA8IDUKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDUKCTwKCWJ6ICp3aGlsZV8xX2VuZAoKCS8vICppZjE0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0MTIKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgNzAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnQgNzAwCgk8CglieiAqaWYxNF9lbmQKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQxMwoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludCAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZSBiNjQgQ29FQiAvLyAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnQgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMTRfZW5kOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0MTYKCS8vIG46IHVpbnQzMltdID0gdGhpcy5nZXRQY2dSYW5kb20oTUlOX05VTUJFUiwgTUFYX05VTUJFUiArIDEsIDEpCglpbnQgMQoJaW50IDUxCglpbnQgMQoJY2FsbHN1YiBnZXRQY2dSYW5kb20KCWZyYW1lX2J1cnkgMyAvLyBuOiB1aW50MzJbXQoKCS8vICppZjE1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0MTgKCS8vIHRoaXMuY2hlY2tVbmlxdWUobnVtYmVycywgaSwgblswXSBhcyB1aW50MTYpCglmcmFtZV9kaWcgMyAvLyBuOiB1aW50MzJbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMCA0CglidG9pCglpdG9iCglkdXAKCWJpdGxlbgoJaW50IDE2Cgk8PQoKCS8vIG5bMF0gYXMgdWludDE2IG92ZXJmbG93ZWQgMTYgYml0cwoJYXNzZXJ0CglleHRyYWN0IDYgMgoJYnRvaQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBudW1iZXJzOiBMb3R0ZXJ5TnVtYmVycwoJY2FsbHN1YiBjaGVja1VuaXF1ZQoJYnogKmlmMTVfZW5kCgoJLy8gKmlmMTVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0MjAKCS8vIG51bWJlcnNbaV0gPSBuWzBdIGFzIHVpbnQxNgoJZnJhbWVfZGlnIDEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDIKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJZnJhbWVfZGlnIDMgLy8gbjogdWludDMyW10KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgNAoJYnRvaQoJaXRvYgoJZXh0cmFjdCA2IDIKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDEgLy8gbnVtYmVyczogTG90dGVyeU51bWJlcnMKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQyMQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqaWYxNV9lbmQ6CgliICp3aGlsZV8xCgoqd2hpbGVfMV9lbmQ6CgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQyNgoJLy8gdGhpcy53aW5uaW5nTnVtYmVycy52YWx1ZSA9IG51bWJlcnMKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWZyYW1lX2RpZyAxIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDI5CgkvLyB0aGlzLkRyYXdFdmVudC5sb2coewoJLy8gICAgICAgbnVtYmVyczogbnVtYmVycywKCS8vICAgICAgIHJhbmRvbW5lc3M6IHJhbmRvbUJ5dGVzLAoJLy8gICAgIH0pCglieXRlIDB4MmFjYjBmYTMgLy8gRHJhd0V2ZW50KHVpbnQxNls1XSxieXRlW10pCglieXRlIDB4IC8vIGluaXRpYWwgaGVhZAoJYnl0ZSAweCAvLyBpbml0aWFsIHRhaWwKCWJ5dGUgMHgwMDBjIC8vIGluaXRpYWwgaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAxIC8vIG51bWJlcnM6IExvdHRlcnlOdW1iZXJzCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyByYW5kb21CeXRlczogYnl0ZXMKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBnZXRSZWZ1bmQoYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfZ2V0UmVmdW5kOgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgZ2V0UmVmdW5kIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGdldFJlZnVuZChhZGRyZXNzKXZvaWQKCWNhbGxzdWIgZ2V0UmVmdW5kCglpbnQgMQoJcmV0dXJuCgovLyBnZXRSZWZ1bmQoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKLy8KLy8KLy8gR2V0IGEgcmVmdW5kIGlmIHRoZSBsb3R0ZXJ5IGlzIG5ldmVyIGRyYXduCmdldFJlZnVuZDoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ0MgoJLy8gYXNzZXJ0KHRoaXMucmFuZG9tbmVzc0V4cGlyZWQoKSwgJ2JlYWNvbiBjb21taXRtZW50IGhhcyBlbGFwc2VkJykKCWNhbGxzdWIgcmFuZG9tbmVzc0V4cGlyZWQKCgkvLyBiZWFjb24gY29tbWl0bWVudCBoYXMgZWxhcHNlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NDMKCS8vIGFzc2VydCghdGhpcy53aW5uaW5nTnVtYmVycy5leGlzdHMsICdsb3R0ZXJ5IGhhcyBub3QgeWV0IGJlZW4gZHJhd24nKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYnl0ZSAweDc3NmUgLy8gInduIgoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoKCS8vIGxvdHRlcnkgaGFzIG5vdCB5ZXQgYmVlbiBkcmF3bgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NDcKCS8vIHZlcmlmeVR4bih0aGlzLnR4biwgewoJLy8gICAgICAgc2VuZGVyOiB7IGluY2x1ZGVkSW46IFt0aGlzLmdldE1hbmFnZXIoKSwgYWRkcmVzc10gfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJY2FsbHN1YiBnZXRNYW5hZ2VyCgk9PQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCT09Cgl8fAoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjp7InR4blRleHQiOiJ0aGlzLnR4biJ9LCJmaWVsZCI6InNlbmRlciIsImNvbmRpdGlvbiI6ImluY2x1ZGVkSW4iLCJleHBlY3RlZCI6Ilt0aGlzLmdldE1hbmFnZXIoKSwgYWRkcmVzc10ifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NTEKCS8vIG51bVRpY2tldHM6IHVpbnQ2NCA9IHRoaXMudXNlckVudHJ5KGFkZHJlc3MpLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMudXNlckVudHJ5KGFkZHJlc3MpLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglsZW4KCWludCAxMAoJLwoJZnJhbWVfYnVyeSAwIC8vIG51bVRpY2tldHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDUyCgkvLyB0aWNrZXRQcmljZTogdWludDY0ID0gdGhpcy50aWNrZXRQcmljZS52YWx1ZQoJYnl0ZSAweDc0NzAgLy8gInRwIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMSAvLyB0aWNrZXRQcmljZTogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NTUKCS8vIHBhaWQ6IHVpbnQ2NCA9IG51bVRpY2tldHMgKiB0aWNrZXRQcmljZQoJZnJhbWVfZGlnIDAgLy8gbnVtVGlja2V0czogdWludDY0CglmcmFtZV9kaWcgMSAvLyB0aWNrZXRQcmljZTogdWludDY0CgkqCglmcmFtZV9idXJ5IDIgLy8gcGFpZDogdWludDY0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NTgKCS8vIGZlZTogdWludDY0ID0gKHBhaWQgKiB0aGlzLmZlZVBlcmNlbnQudmFsdWUpIC8gMTAwCglmcmFtZV9kaWcgMiAvLyBwYWlkOiB1aW50NjQKCWJ5dGUgMHg2NjcwIC8vICJmcCIKCWFwcF9nbG9iYWxfZ2V0CgkqCglpbnQgMTAwCgkvCglmcmFtZV9idXJ5IDMgLy8gZmVlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ2MQoJLy8gdGhpcy50b3RhbEZlZXMudmFsdWUgLT0gZmVlCglieXRlIDB4NzQ2NiAvLyAidGYiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDMgLy8gZmVlOiB1aW50NjQKCS0KCWJ5dGUgMHg3NDY2IC8vICJ0ZiIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NjQKCS8vIHRoaXMucHJpemVQb29sLnZhbHVlIC09IHBhaWQgLSBmZWUKCWJ5dGUgMHg3MDcwIC8vICJwcCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMiAvLyBwYWlkOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIGZlZTogdWludDY0CgktCgktCglieXRlIDB4NzA3MCAvLyAicHAiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDY3CgkvLyB0aGlzLnRpY2tldHNTb2xkLnZhbHVlIC09IG51bVRpY2tldHMKCWJ5dGUgMHg3NDczIC8vICJ0cyIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMCAvLyBudW1UaWNrZXRzOiB1aW50NjQKCS0KCWJ5dGUgMHg3NDczIC8vICJ0cyIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NzAKCS8vIGFzc2V0UmVjZWl2ZXIgPSBhZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJZnJhbWVfYnVyeSA0IC8vIGFzc2V0UmVjZWl2ZXI6IGFkZHJlc3MKCgkvLyAqaWYxNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDczCgkvLyAhYWRkcmVzcy5pc09wdGVkSW5Ub0Fzc2V0KHRoaXMuYXNhLnZhbHVlKQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWJ5dGUgMHg2MTczIC8vICJhcyIKCWFwcF9nbG9iYWxfZ2V0Cglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXN3YXAKCXBvcAoJIQoJYnogKmlmMTZfZW5kCgoJLy8gKmlmMTZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NzQKCS8vIGFzc2V0UmVjZWl2ZXIgPSB0aGlzLmdldE1hbmFnZXIoKQoJY2FsbHN1YiBnZXRNYW5hZ2VyCglmcmFtZV9idXJ5IDQgLy8gYXNzZXRSZWNlaXZlcjogYWRkcmVzcwoKKmlmMTZfZW5kOgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0NzcKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGFzc2V0UmVjZWl2ZXIsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IHRoaXMuYXNhLnZhbHVlLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHBhaWQsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgICBub3RlOiAnYmV0IHJlZnVuZCcsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NDc4CgkvLyBhc3NldFJlY2VpdmVyOiBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgNCAvLyBhc3NldFJlY2VpdmVyOiBhZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ3OQoJLy8geGZlckFzc2V0OiB0aGlzLmFzYS52YWx1ZQoJYnl0ZSAweDYxNzMgLy8gImFzIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0ODAKCS8vIGFzc2V0QW1vdW50OiBwYWlkCglmcmFtZV9kaWcgMiAvLyBwYWlkOiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ4MQoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ4MgoJLy8gbm90ZTogJ2JldCByZWZ1bmQnCglieXRlIDB4NjI2NTc0MjA3MjY1NjY3NTZlNjQgLy8gImJldCByZWZ1bmQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo0ODYKCS8vIHRoaXMuZGVsZXRlQm94QW5kUmVmdW5kKGFkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJY2FsbHN1YiBkZWxldGVCb3hBbmRSZWZ1bmQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjQ4OQoJLy8gdGhpcy5SZWZ1bmRFdmVudC5sb2coewoJLy8gICAgICAgYWRkcmVzczogYWRkcmVzcywKCS8vICAgICAgIGFtb3VudDogcGFpZCwKCS8vICAgICB9KQoJYnl0ZSAweDY1MDViYWE1IC8vIFJlZnVuZEV2ZW50KGFkZHJlc3MsdWludDY0KQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIHBhaWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBwYXlXaW5uZXIoYWRkcmVzcyx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3BheVdpbm5lcjoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChhZGRyZXNzKSBmb3IgcGF5V2lubmVyIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIHBheVdpbm5lcihhZGRyZXNzLHVpbnQ2NCl2b2lkCgljYWxsc3ViIHBheVdpbm5lcgoJaW50IDEKCXJldHVybgoKLy8gcGF5V2lubmVyKGFkZHJlc3M6IEFkZHJlc3MsIGFtb3VudDogdWludDY0KTogdm9pZAovLwovLwovLyBQYXlvdXQgd2lubmluZyB1c2Vycywgb25seSBjYWxsYWJsZSBieSBtYW5hZ2VyCi8vIEBwYXJhbSBhZGRyZXNzIEFkZHJlc3Mgb2YgdGhlIHVzZXIKLy8gQHBhcmFtIGFtb3VudCBIb3cgbXVjaCBvZiBhc2EgdG8gc2VuZApwYXlXaW5uZXI6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjUwNAoJLy8gYXNzZXJ0KHRoaXMuaXNNYW5hZ2VyKCksICdjYWxsZXIgaXMgbWFuYWdlcicpCgljYWxsc3ViIGlzTWFuYWdlcgoKCS8vIGNhbGxlciBpcyBtYW5hZ2VyCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjUwNQoJLy8gYXNzZXJ0KHRoaXMud2lubmluZ051bWJlcnMuZXhpc3RzLCAnbG90dGVyeSBtdXN0IGJlIGRyYXduJykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCgkvLyBsb3R0ZXJ5IG11c3QgYmUgZHJhd24KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NTA3CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiB0aGlzLmFzYS52YWx1ZSwKCS8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgICBub3RlOiAnYmV0IHBheW91dCcsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NTA4CgkvLyBhc3NldFJlY2VpdmVyOiBhZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo1MDkKCS8vIHhmZXJBc3NldDogdGhpcy5hc2EudmFsdWUKCWJ5dGUgMHg2MTczIC8vICJhcyIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NTEwCgkvLyBhc3NldEFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgLTIgLy8gYW1vdW50OiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjUxMQoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjUxMgoJLy8gbm90ZTogJ2JldCBwYXlvdXQnCglieXRlIDB4NjI2NTc0MjA3MDYxNzk2Zjc1NzQgLy8gImJldCBwYXlvdXQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL0xvdHRlcnkuYWxnby50czo1MTYKCS8vIHRoaXMucHJpemVQb29sLnZhbHVlIC09IGFtb3VudAoJYnl0ZSAweDcwNzAgLy8gInBwIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJYnl0ZSAweDcwNzAgLy8gInBwIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjUxOQoJLy8gdGhpcy5kZWxldGVCb3hBbmRSZWZ1bmQoYWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCgljYWxsc3ViIGRlbGV0ZUJveEFuZFJlZnVuZAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NTIyCgkvLyB0aGlzLldpbm5lclBhaWRFdmVudC5sb2coewoJLy8gICAgICAgYW1vdW50OiBhbW91bnQsCgkvLyAgICAgICBhZGRyZXNzOiBhZGRyZXNzLAoJLy8gICAgIH0pCglieXRlIDB4OTdhZjA5ZTIgLy8gV2lubmVyUGFpZEV2ZW50KHVpbnQ2NCxhZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyB1c2VyQ2xlYW51cChhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV91c2VyQ2xlYW51cDoKCS8vIGFkZHJlc3M6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoYWRkcmVzcykgZm9yIHVzZXJDbGVhbnVwIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIHVzZXJDbGVhbnVwKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiB1c2VyQ2xlYW51cAoJaW50IDEKCXJldHVybgoKLy8gdXNlckNsZWFudXAoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKLy8KLy8KLy8gQWxsb3cgdXNlcnMgYm94IHN0b3JhZ2UgdG8gYmUgZGVsZXRlZCBhbmQgTUJSIGNvc3QgcmVmdW5kZWQgdG8gdGhlIHVzZXIKLy8gQHBhcmFtIGFkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdXNlcgp1c2VyQ2xlYW51cDoKCXByb3RvIDEgMAoKCS8vIGNvbnRyYWN0cy9Mb3R0ZXJ5LmFsZ28udHM6NTM2CgkvLyBhc3NlcnQodGhpcy53aW5uaW5nTnVtYmVycy5leGlzdHMsICdsb3R0ZXJ5IGhhcyBiZWVuIGRyYXduJykKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg3NzZlIC8vICJ3biIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCgkvLyBsb3R0ZXJ5IGhhcyBiZWVuIGRyYXduCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjU0MAoJLy8gdmVyaWZ5VHhuKHRoaXMudHhuLCB7CgkvLyAgICAgICBzZW5kZXI6IHsgaW5jbHVkZWRJbjogW3RoaXMuZ2V0TWFuYWdlcigpLCBhZGRyZXNzXSB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldE1hbmFnZXIKCT09Cgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJPT0KCXx8CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOnsidHhuVGV4dCI6InRoaXMudHhuIn0sImZpZWxkIjoic2VuZGVyIiwiY29uZGl0aW9uIjoiaW5jbHVkZWRJbiIsImV4cGVjdGVkIjoiW3RoaXMuZ2V0TWFuYWdlcigpLCBhZGRyZXNzXSJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTG90dGVyeS5hbGdvLnRzOjU0NQoJLy8gdGhpcy5kZWxldGVCb3hBbmRSZWZ1bmQoYWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCgljYWxsc3ViIGRlbGV0ZUJveEFuZFJlZnVuZAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJzZXRNYW5hZ2VyKGFkZHJlc3Mpdm9pZCIKCW1ldGhvZCAiZ2V0TWFuYWdlcigpYWRkcmVzcyIKCW1ldGhvZCAiZ2V0TWJyQ29zdCh1aW50MTZbNV1bXSl1aW50NjQiCgltZXRob2QgImdldFdpbm5pbmdOdW1iZXJzKCl1aW50MTZbNV0iCgltZXRob2QgImJvb3RzdHJhcCgpdm9pZCIKCW1ldGhvZCAiYWRkUHJpemVQb29sKGF4ZmVyKXZvaWQiCgltZXRob2QgInNldEVudHJ5KGF4ZmVyLHVpbnQxNls1XVtdKXZvaWQiCgltZXRob2QgImRyYXcoKXZvaWQiCgltZXRob2QgImdldFJlZnVuZChhZGRyZXNzKXZvaWQiCgltZXRob2QgInBheVdpbm5lcihhZGRyZXNzLHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJ1c2VyQ2xlYW51cChhZGRyZXNzKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX3NldE1hbmFnZXIgKmFiaV9yb3V0ZV9nZXRNYW5hZ2VyICphYmlfcm91dGVfZ2V0TWJyQ29zdCAqYWJpX3JvdXRlX2dldFdpbm5pbmdOdW1iZXJzICphYmlfcm91dGVfYm9vdHN0cmFwICphYmlfcm91dGVfYWRkUHJpemVQb29sICphYmlfcm91dGVfc2V0RW50cnkgKmFiaV9yb3V0ZV9kcmF3ICphYmlfcm91dGVfZ2V0UmVmdW5kICphYmlfcm91dGVfcGF5V2lubmVyICphYmlfcm91dGVfdXNlckNsZWFudXAKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnIKCipjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uOgoJbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBEZWxldGVBcHBsaWNhdGlvbgoJZXJyCgoqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50Cgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1YgoKKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0Cgljb25jYXQKCWZyYW1lX2J1cnkgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWR1cAoJbGVuCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWJ0b2kKCSsKCWl0b2IKCWV4dHJhY3QgNiAyCglmcmFtZV9idXJ5IC0yIC8vIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJc3dhcAoJY29uY2F0CglmcmFtZV9idXJ5IC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWI=",
    clear: "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  contract: {
    name: "Lottery",
    desc: "",
    methods: [
      {
        name: "setManager",
        desc: "Changes which address can manage this contract",
        args: [
          {
            name: "manager",
            type: "address",
            desc: "the Address that will be able to manage the contract",
          },
        ],
        returns: {
          type: "void",
        },
      },
      {
        name: "getManager",
        desc: "Returns the current manager",
        args: [],
        returns: {
          type: "address",
          desc: "The current managers Address",
        },
      },
      {
        name: "getMbrCost",
        desc: "Gets MBR cost for the box",
        readonly: true,
        args: [
          {
            name: "entry",
            type: "uint16[5][]",
          },
        ],
        returns: {
          type: "uint64",
          desc: "MBR cost for the box",
        },
      },
      {
        name: "getWinningNumbers",
        desc: "Returns the winning lottery numbers (can use algod simulate instead of indexer)",
        readonly: true,
        args: [],
        returns: {
          type: "uint16[5]",
          desc: "The winning lottery numbers as a`LotteryNumbers`type",
        },
      },
      {
        name: "createApplication",
        desc: "create the application",
        args: [
          {
            name: "name",
            type: "string",
            desc: "the Name of the lottery",
          },
          {
            name: "asa",
            type: "uint64",
            desc: "the Asset we accept as payment",
          },
          {
            name: "beaconAppId",
            type: "uint64",
            desc: "AppID of the randomness beacon",
          },
          {
            name: "endRound",
            type: "uint64",
            desc: "the round from when the lottery will no longer allow entries",
          },
          {
            name: "drawRound",
            type: "uint64",
            desc: "the round from when we can draw the lottery",
          },
          {
            name: "ticketPrice",
            type: "uint64",
            desc: "how much does a ticket cost",
          },
          {
            name: "feePercent",
            type: "uint64",
            desc: "what percent of ticketPrice will we take as fees",
          },
        ],
        returns: {
          type: "void",
        },
      },
      {
        name: "deleteApplication",
        desc: "Delete application and closeOut to manager address",
        args: [],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "DeleteEvent",
            args: [
              {
                name: "fees",
                type: "uint64",
              },
              {
                name: "prizePool",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "bootstrap",
        desc: "Initialiase the app after creation",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "addPrizePool",
        desc: "Add additional prizepool asa",
        args: [
          {
            name: "axfer",
            type: "axfer",
            desc: "the asset transfer txn",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "PrizePoolAddedEvent",
            args: [
              {
                name: "amount",
                type: "uint64",
              },
              {
                name: "address",
                type: "address",
              },
              {
                name: "total",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "setEntry",
        desc: "Allow user to purchase ticket(s) of the lottery",
        args: [
          {
            name: "axfer",
            type: "axfer",
            desc: "AssetTransferTxn to pay for the tickets",
          },
          {
            name: "entry",
            type: "uint16[5][]",
            desc: "LotteryNumbers[] for the user",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "BuyTicketEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "entries",
                type: "uint16[5][]",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "draw",
        desc: "Perform the lottery draw and set`winningNumbers`",
        args: [],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "DrawEvent",
            args: [
              {
                name: "numbers",
                type: "uint16[5]",
              },
              {
                name: "randomness",
                type: "byte[]",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "getRefund",
        desc: "Get a refund if the lottery is never drawn",
        args: [
          {
            name: "address",
            type: "address",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "RefundEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "amount",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "payWinner",
        desc: "Payout winning users, only callable by manager",
        args: [
          {
            name: "address",
            type: "address",
            desc: "Address of the user",
          },
          {
            name: "amount",
            type: "uint64",
            desc: "How much of asa to send",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "WinnerPaidEvent",
            args: [
              {
                name: "amount",
                type: "uint64",
              },
              {
                name: "address",
                type: "address",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "userCleanup",
        desc: "Allow users box storage to be deleted and MBR cost refunded to the user",
        args: [
          {
            name: "address",
            type: "address",
            desc: "Address of the user",
          },
        ],
        returns: {
          type: "void",
        },
      },
    ],
    events: [
      {
        name: "PrizePoolAddedEvent",
        args: [
          {
            name: "amount",
            type: "uint64",
          },
          {
            name: "address",
            type: "address",
          },
          {
            name: "total",
            type: "uint64",
          },
        ],
        desc: "",
      },
      {
        name: "BuyTicketEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "entries",
            type: "uint16[5][]",
          },
        ],
        desc: "",
      },
      {
        name: "RefundEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "amount",
            type: "uint64",
          },
        ],
        desc: "",
      },
      {
        name: "DrawEvent",
        args: [
          {
            name: "numbers",
            type: "uint16[5]",
          },
          {
            name: "randomness",
            type: "byte[]",
          },
        ],
        desc: "",
      },
      {
        name: "WinnerPaidEvent",
        args: [
          {
            name: "amount",
            type: "uint64",
          },
          {
            name: "address",
            type: "address",
          },
        ],
        desc: "",
      },
      {
        name: "DeleteEvent",
        args: [
          {
            name: "fees",
            type: "uint64",
          },
          {
            name: "prizePool",
            type: "uint64",
          },
        ],
        desc: "",
      },
    ],
  },
};

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp = {
  onCompleteAction?: "no_op" | OnApplicationComplete.NoOpOC;
};
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn = {
  onCompleteAction: "opt_in" | OnApplicationComplete.OptInOC;
};
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut = {
  onCompleteAction: "close_out" | OnApplicationComplete.CloseOutOC;
};
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp = {
  onCompleteAction:
    | "delete_application"
    | OnApplicationComplete.DeleteApplicationOC;
};
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp = {
  onCompleteAction:
    | "update_application"
    | OnApplicationComplete.UpdateApplicationOC;
};
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint;
  /**
   * Gets the state value as a number.
   */
  asNumber(): number;
};
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array;
  /**
   * Gets the state value as a string
   */
  asString(): string;
};

export type AppCreateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult> &
  AppReference;
export type AppUpdateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult>;

export type AppClientComposeCallCoreParams = Omit<
  AppClientCallCoreParams,
  "sendParams"
> & {
  sendParams?: Omit<
    SendTransactionParams,
    | "skipSending"
    | "atc"
    | "skipWaiting"
    | "maxRoundsToWaitForConfirmation"
    | "populateAppCallResources"
  >;
};
export type AppClientComposeExecuteParams = Pick<
  SendTransactionParams,
  | "skipWaiting"
  | "maxRoundsToWaitForConfirmation"
  | "populateAppCallResources"
  | "suppressLog"
>;

/**
 * Defines the types of available calls and state of the Lottery smart contract.
 */
export type Lottery = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    "setManager(address)void" | "setManager",
    {
      argsObj: {
        /**
         * the Address that will be able to manage the contract
         */
        manager: string;
      };
      argsTuple: [manager: string];
      returns: void;
    }
  > &
    Record<
      "getManager()address" | "getManager",
      {
        argsObj: {};
        argsTuple: [];
        /**
         * The current managers Address
         */
        returns: string;
      }
    > &
    Record<
      "getMbrCost(uint16[5][])uint64" | "getMbrCost",
      {
        argsObj: {
          entry: [number, number, number, number, number][];
        };
        argsTuple: [entry: [number, number, number, number, number][]];
        /**
         * MBR cost for the box
         */
        returns: bigint;
      }
    > &
    Record<
      "getWinningNumbers()uint16[5]" | "getWinningNumbers",
      {
        argsObj: {};
        argsTuple: [];
        /**
         * The winning lottery numbers as a`LotteryNumbers`type
         */
        returns: [number, number, number, number, number];
      }
    > &
    Record<
      | "createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void"
      | "createApplication",
      {
        argsObj: {
          /**
           * the Name of the lottery
           */
          name: string;
          /**
           * the Asset we accept as payment
           */
          asa: bigint | number;
          /**
           * AppID of the randomness beacon
           */
          beaconAppId: bigint | number;
          /**
           * the round from when the lottery will no longer allow entries
           */
          endRound: bigint | number;
          /**
           * the round from when we can draw the lottery
           */
          drawRound: bigint | number;
          /**
           * how much does a ticket cost
           */
          ticketPrice: bigint | number;
          /**
           * what percent of ticketPrice will we take as fees
           */
          feePercent: bigint | number;
        };
        argsTuple: [
          name: string,
          asa: bigint | number,
          beaconAppId: bigint | number,
          endRound: bigint | number,
          drawRound: bigint | number,
          ticketPrice: bigint | number,
          feePercent: bigint | number
        ];
        returns: void;
      }
    > &
    Record<
      "deleteApplication()void" | "deleteApplication",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "bootstrap()void" | "bootstrap",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "addPrizePool(axfer)void" | "addPrizePool",
      {
        argsObj: {
          /**
           * the asset transfer txn
           */
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>;
        };
        argsTuple: [
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>
        ];
        returns: void;
      }
    > &
    Record<
      "setEntry(axfer,uint16[5][])void" | "setEntry",
      {
        argsObj: {
          /**
           * AssetTransferTxn to pay for the tickets
           */
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>;
          /**
           * LotteryNumbers[] for the user
           */
          entry: [number, number, number, number, number][];
        };
        argsTuple: [
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>,
          entry: [number, number, number, number, number][]
        ];
        returns: void;
      }
    > &
    Record<
      "draw()void" | "draw",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "getRefund(address)void" | "getRefund",
      {
        argsObj: {
          address: string;
        };
        argsTuple: [address: string];
        returns: void;
      }
    > &
    Record<
      "payWinner(address,uint64)void" | "payWinner",
      {
        argsObj: {
          /**
           * Address of the user
           */
          address: string;
          /**
           * How much of asa to send
           */
          amount: bigint | number;
        };
        argsTuple: [address: string, amount: bigint | number];
        returns: void;
      }
    > &
    Record<
      "userCleanup(address)void" | "userCleanup",
      {
        argsObj: {
          /**
           * Address of the user
           */
          address: string;
        };
        argsTuple: [address: string];
        returns: void;
      }
    >;
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      ma?: BinaryState;
      ba?: IntegerState;
      dr?: IntegerState;
      ra?: BinaryState;
      ps?: IntegerState;
      na?: BinaryState;
      as?: IntegerState;
      tp?: IntegerState;
      fp?: IntegerState;
      er?: IntegerState;
      ts?: IntegerState;
      tf?: IntegerState;
      pp?: IntegerState;
      wn?: BinaryState;
    };
  };
};
/**
 * Defines the possible abi call signatures
 */
export type LotterySig = keyof Lottery["methods"];
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends LotterySig | undefined> = {
  method: TSignature;
  methodArgs: TSignature extends undefined
    ? undefined
    : Array<ABIAppCallArg | undefined>;
} & AppClientCallCoreParams &
  CoreAppCallArgs;
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>;
/**
 * Maps a method signature from the Lottery smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends LotterySig> =
  Lottery["methods"][TSignature]["argsObj" | "argsTuple"];
/**
 * Maps a method signature from the Lottery smart contract to the method's return type
 */
export type MethodReturn<TSignature extends LotterySig> =
  Lottery["methods"][TSignature]["returns"];

/**
 * A factory for available 'create' calls
 */
export type LotteryCreateCalls = (typeof LotteryCallFactory)["create"];
/**
 * Defines supported create methods for this smart contract
 */
export type LotteryCreateCallParams =
  TypedCallParams<"createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void"> &
    OnCompleteNoOp;
/**
 * A factory for available 'delete' calls
 */
export type LotteryDeleteCalls = (typeof LotteryCallFactory)["delete"];
/**
 * Defines supported delete methods for this smart contract
 */
export type LotteryDeleteCallParams =
  TypedCallParams<"deleteApplication()void">;
/**
 * Defines arguments required for the deploy method.
 */
export type LotteryDeployArgs = {
  deployTimeParams?: TealTemplateParams;
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: LotteryCreateCalls) => LotteryCreateCallParams;
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: LotteryDeleteCalls) => LotteryDeleteCallParams;
};

/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class LotteryCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the Lottery smart contract using the createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(
        args: MethodArgs<"createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void">,
        params: AppClientCallCoreParams &
          CoreAppCallArgs &
          AppClientCompilationParams &
          OnCompleteNoOp = {}
      ) {
        return {
          method:
            "createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void" as const,
          methodArgs: Array.isArray(args)
            ? args
            : [
                args.name,
                args.asa,
                args.beaconAppId,
                args.endRound,
                args.drawRound,
                args.ticketPrice,
                args.feePercent,
              ],
          ...params,
        };
      },
    };
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the Lottery smart contract using the deleteApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams & CoreAppCallArgs = {}
      ) {
        return {
          method: "deleteApplication()void" as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Constructs a no op call for the setManager(address)void ABI method
   *
   * Changes which address can manage this contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setManager(
    args: MethodArgs<"setManager(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "setManager(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.manager],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getManager()address ABI method
   *
   * Returns the current manager
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getManager(
    args: MethodArgs<"getManager()address">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getManager()address" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getMbrCost(uint16[5][])uint64 ABI method
   *
   * Gets MBR cost for the box
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getMbrCost(
    args: MethodArgs<"getMbrCost(uint16[5][])uint64">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getMbrCost(uint16[5][])uint64" as const,
      methodArgs: Array.isArray(args) ? args : [args.entry],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getWinningNumbers()uint16[5] ABI method
   *
   * Returns the winning lottery numbers (can use algod simulate instead of indexer)
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getWinningNumbers(
    args: MethodArgs<"getWinningNumbers()uint16[5]">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getWinningNumbers()uint16[5]" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the bootstrap()void ABI method
   *
   * Initialiase the app after creation
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "bootstrap()void" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the addPrizePool(axfer)void ABI method
   *
   * Add additional prizepool asa
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "addPrizePool(axfer)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.axfer],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the setEntry(axfer,uint16[5][])void ABI method
   *
   * Allow user to purchase ticket(s) of the lottery
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setEntry(
    args: MethodArgs<"setEntry(axfer,uint16[5][])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "setEntry(axfer,uint16[5][])void" as const,
      methodArgs: Array.isArray(args) ? args : [args.axfer, args.entry],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the draw()void ABI method
   *
   * Perform the lottery draw and set`winningNumbers`
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static draw(
    args: MethodArgs<"draw()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "draw()void" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getRefund(address)void ABI method
   *
   * Get a refund if the lottery is never drawn
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getRefund(
    args: MethodArgs<"getRefund(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getRefund(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the payWinner(address,uint64)void ABI method
   *
   * Payout winning users, only callable by manager
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static payWinner(
    args: MethodArgs<"payWinner(address,uint64)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "payWinner(address,uint64)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.address, args.amount],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the userCleanup(address)void ABI method
   *
   * Allow users box storage to be deleted and MBR cost refunded to the user
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static userCleanup(
    args: MethodArgs<"userCleanup(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "userCleanup(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    };
  }
}

/**
 * A client to make calls to the Lottery smart contract
 */
export class LotteryClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient;

  private readonly sender: SendTransactionFrom | undefined;

  /**
   * Creates a new instance of `LotteryClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender;
    this.appClient = algokit.getAppClient(
      {
        ...appDetails,
        app: APP_SPEC,
      },
      algod
    );
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<
    TReturn,
    TResult extends AppCallTransactionResult = AppCallTransactionResult
  >(
    result: AppCallTransactionResult,
    returnValueFormatter?: (value: any) => TReturn
  ): AppCallTransactionResultOfType<TReturn> & TResult {
    if (result.return?.decodeError) {
      throw result.return.decodeError;
    }
    const returnValue =
      result.return?.returnValue !== undefined &&
      returnValueFormatter !== undefined
        ? returnValueFormatter(result.return.returnValue)
        : (result.return?.returnValue as TReturn | undefined);
    return {
      ...result,
      return: returnValue,
    } as AppCallTransactionResultOfType<TReturn> & TResult;
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof Lottery["methods"]>(
    typedCallParams: TypedCallParams<TSignature>,
    returnValueFormatter?: (value: any) => MethodReturn<TSignature>
  ) {
    return this.mapReturnValue<MethodReturn<TSignature>>(
      await this.appClient.call(typedCallParams),
      returnValueFormatter
    );
  }

  /**
   * Idempotently deploys the Lottery smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(
    params: LotteryDeployArgs & AppClientDeployCoreParams = {}
  ): ReturnType<ApplicationClient["deploy"]> {
    const createArgs = params.createCall?.(LotteryCallFactory.create);
    const deleteArgs = params.deleteCall?.(LotteryCallFactory.delete);
    return this.appClient.deploy({
      ...params,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    });
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this;
    return {
      /**
       * Creates a new instance of the Lottery smart contract using the createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(
        args: MethodArgs<"createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void">,
        params: AppClientCallCoreParams &
          AppClientCompilationParams &
          OnCompleteNoOp = {}
      ) {
        return $this.mapReturnValue<
          MethodReturn<"createApplication(string,uint64,uint64,uint64,uint64,uint64,uint64)void">,
          AppCreateCallTransactionResult
        >(
          await $this.appClient.create(
            LotteryCallFactory.create.createApplication(args, params)
          )
        );
      },
    };
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this;
    return {
      /**
       * Deletes an existing instance of the Lottery smart contract using the deleteApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams = {}
      ) {
        return $this.mapReturnValue<MethodReturn<"deleteApplication()void">>(
          await $this.appClient.delete(
            LotteryCallFactory.delete.deleteApplication(args, params)
          )
        );
      },
    };
  }

  /**
   * Makes a clear_state call to an existing instance of the Lottery smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(
    args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.appClient.clearState(args);
  }

  /**
   * Calls the setManager(address)void ABI method.
   *
   * Changes which address can manage this contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setManager(
    args: MethodArgs<"setManager(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.setManager(args, params));
  }

  /**
   * Calls the getManager()address ABI method.
   *
   * Returns the current manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The current managers Address
   */
  public getManager(
    args: MethodArgs<"getManager()address">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.getManager(args, params));
  }

  /**
   * Calls the getMbrCost(uint16[5][])uint64 ABI method.
   *
   * Gets MBR cost for the box
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: MBR cost for the box
   */
  public getMbrCost(
    args: MethodArgs<"getMbrCost(uint16[5][])uint64">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.getMbrCost(args, params));
  }

  /**
   * Calls the getWinningNumbers()uint16[5] ABI method.
   *
   * Returns the winning lottery numbers (can use algod simulate instead of indexer)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The winning lottery numbers as a`LotteryNumbers`type
   */
  public getWinningNumbers(
    args: MethodArgs<"getWinningNumbers()uint16[5]">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.getWinningNumbers(args, params));
  }

  /**
   * Calls the bootstrap()void ABI method.
   *
   * Initialiase the app after creation
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.bootstrap(args, params));
  }

  /**
   * Calls the addPrizePool(axfer)void ABI method.
   *
   * Add additional prizepool asa
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.addPrizePool(args, params));
  }

  /**
   * Calls the setEntry(axfer,uint16[5][])void ABI method.
   *
   * Allow user to purchase ticket(s) of the lottery
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setEntry(
    args: MethodArgs<"setEntry(axfer,uint16[5][])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.setEntry(args, params));
  }

  /**
   * Calls the draw()void ABI method.
   *
   * Perform the lottery draw and set`winningNumbers`
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public draw(
    args: MethodArgs<"draw()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.draw(args, params));
  }

  /**
   * Calls the getRefund(address)void ABI method.
   *
   * Get a refund if the lottery is never drawn
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getRefund(
    args: MethodArgs<"getRefund(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.getRefund(args, params));
  }

  /**
   * Calls the payWinner(address,uint64)void ABI method.
   *
   * Payout winning users, only callable by manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public payWinner(
    args: MethodArgs<"payWinner(address,uint64)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.payWinner(args, params));
  }

  /**
   * Calls the userCleanup(address)void ABI method.
   *
   * Allow users box storage to be deleted and MBR cost refunded to the user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public userCleanup(
    args: MethodArgs<"userCleanup(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(LotteryCallFactory.userCleanup(args, params));
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(
    state: AppState,
    key: string
  ): BinaryState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if (!("valueRaw" in value))
      throw new Error(
        `Failed to parse state value for ${key}; received an int when expected a byte array`
      );
    return {
      asString(): string {
        return value.value;
      },
      asByteArray(): Uint8Array {
        return value.valueRaw;
      },
    };
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(
    state: AppState,
    key: string
  ): IntegerState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if ("valueRaw" in value)
      throw new Error(
        `Failed to parse state value for ${key}; received a byte array when expected a number`
      );
    return {
      asBigInt() {
        return typeof value.value === "bigint"
          ? value.value
          : BigInt(value.value);
      },
      asNumber(): number {
        return typeof value.value === "bigint"
          ? Number(value.value)
          : value.value;
      },
    };
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<Lottery["state"]["global"]> {
    const state = await this.appClient.getGlobalState();
    return {
      get ma() {
        return LotteryClient.getBinaryState(state, "ma");
      },
      get ba() {
        return LotteryClient.getIntegerState(state, "ba");
      },
      get dr() {
        return LotteryClient.getIntegerState(state, "dr");
      },
      get ra() {
        return LotteryClient.getBinaryState(state, "ra");
      },
      get ps() {
        return LotteryClient.getIntegerState(state, "ps");
      },
      get na() {
        return LotteryClient.getBinaryState(state, "na");
      },
      get as() {
        return LotteryClient.getIntegerState(state, "as");
      },
      get tp() {
        return LotteryClient.getIntegerState(state, "tp");
      },
      get fp() {
        return LotteryClient.getIntegerState(state, "fp");
      },
      get er() {
        return LotteryClient.getIntegerState(state, "er");
      },
      get ts() {
        return LotteryClient.getIntegerState(state, "ts");
      },
      get tf() {
        return LotteryClient.getIntegerState(state, "tf");
      },
      get pp() {
        return LotteryClient.getIntegerState(state, "pp");
      },
      get wn() {
        return LotteryClient.getBinaryState(state, "wn");
      },
    };
  }

  public compose(): LotteryComposer {
    const client = this;
    const atc = new AtomicTransactionComposer();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: any) => any)> = [];
    return {
      setManager(
        args: MethodArgs<"setManager(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.setManager(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getManager(
        args: MethodArgs<"getManager()address">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getManager(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getMbrCost(
        args: MethodArgs<"getMbrCost(uint16[5][])uint64">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getMbrCost(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getWinningNumbers(
        args: MethodArgs<"getWinningNumbers()uint16[5]">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getWinningNumbers(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      bootstrap(
        args: MethodArgs<"bootstrap()void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.bootstrap(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      addPrizePool(
        args: MethodArgs<"addPrizePool(axfer)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.addPrizePool(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      setEntry(
        args: MethodArgs<"setEntry(axfer,uint16[5][])void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.setEntry(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      draw(
        args: MethodArgs<"draw()void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.draw(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getRefund(
        args: MethodArgs<"getRefund(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getRefund(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      payWinner(
        args: MethodArgs<"payWinner(address,uint64)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.payWinner(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      userCleanup(
        args: MethodArgs<"userCleanup(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.userCleanup(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      get delete() {
        const $this = this;
        return {
          deleteApplication(
            args: MethodArgs<"deleteApplication()void">,
            params?: AppClientComposeCallCoreParams
          ) {
            promiseChain = promiseChain.then(() =>
              client.delete.deleteApplication(args, {
                ...params,
                sendParams: { ...params?.sendParams, skipSending: true, atc },
              })
            );
            resultMappers.push(undefined);
            return $this;
          },
        };
      },
      clearState(
        args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.clearState({
            ...args,
            sendParams: { ...args?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      addTransaction(
        txn:
          | TransactionWithSigner
          | TransactionToSign
          | Transaction
          | Promise<SendTransactionResult>,
        defaultSender?: SendTransactionFrom
      ) {
        promiseChain = promiseChain.then(async () =>
          atc.addTransaction(
            await algokit.getTransactionWithSigner(
              txn,
              defaultSender ?? client.sender
            )
          )
        );
        return this;
      },
      async atc() {
        await promiseChain;
        return atc;
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain;
        const result = await atc.simulate(
          client.algod,
          new modelsv2.SimulateRequest({ txnGroups: [], ...options })
        );
        return {
          ...result,
          returns: result.methodResults?.map((val, i) =>
            resultMappers[i] !== undefined
              ? resultMappers[i]!(val.returnValue)
              : val.returnValue
          ),
        };
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain;
        const result = await algokit.sendAtomicTransactionComposer(
          { atc, sendParams },
          client.algod
        );
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined
              ? resultMappers[i]!(val.returnValue)
              : val.returnValue
          ),
        };
      },
    } as unknown as LotteryComposer;
  }
}
export type LotteryComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the setManager(address)void ABI method.
   *
   * Changes which address can manage this contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setManager(
    args: MethodArgs<"setManager(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"setManager(address)void">]>;

  /**
   * Calls the getManager()address ABI method.
   *
   * Returns the current manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getManager(
    args: MethodArgs<"getManager()address">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"getManager()address">]>;

  /**
   * Calls the getMbrCost(uint16[5][])uint64 ABI method.
   *
   * Gets MBR cost for the box
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getMbrCost(
    args: MethodArgs<"getMbrCost(uint16[5][])uint64">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<
    [...TReturns, MethodReturn<"getMbrCost(uint16[5][])uint64">]
  >;

  /**
   * Calls the getWinningNumbers()uint16[5] ABI method.
   *
   * Returns the winning lottery numbers (can use algod simulate instead of indexer)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getWinningNumbers(
    args: MethodArgs<"getWinningNumbers()uint16[5]">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<
    [...TReturns, MethodReturn<"getWinningNumbers()uint16[5]">]
  >;

  /**
   * Calls the bootstrap()void ABI method.
   *
   * Initialiase the app after creation
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"bootstrap()void">]>;

  /**
   * Calls the addPrizePool(axfer)void ABI method.
   *
   * Add additional prizepool asa
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"addPrizePool(axfer)void">]>;

  /**
   * Calls the setEntry(axfer,uint16[5][])void ABI method.
   *
   * Allow user to purchase ticket(s) of the lottery
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setEntry(
    args: MethodArgs<"setEntry(axfer,uint16[5][])void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<
    [...TReturns, MethodReturn<"setEntry(axfer,uint16[5][])void">]
  >;

  /**
   * Calls the draw()void ABI method.
   *
   * Perform the lottery draw and set`winningNumbers`
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  draw(
    args: MethodArgs<"draw()void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"draw()void">]>;

  /**
   * Calls the getRefund(address)void ABI method.
   *
   * Get a refund if the lottery is never drawn
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getRefund(
    args: MethodArgs<"getRefund(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"getRefund(address)void">]>;

  /**
   * Calls the payWinner(address,uint64)void ABI method.
   *
   * Payout winning users, only callable by manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  payWinner(
    args: MethodArgs<"payWinner(address,uint64)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<
    [...TReturns, MethodReturn<"payWinner(address,uint64)void">]
  >;

  /**
   * Calls the userCleanup(address)void ABI method.
   *
   * Allow users box storage to be deleted and MBR cost refunded to the user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  userCleanup(
    args: MethodArgs<"userCleanup(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, MethodReturn<"userCleanup(address)void">]>;

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the Lottery smart contract using the deleteApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteApplication(
      args: MethodArgs<"deleteApplication()void">,
      params?: AppClientComposeCallCoreParams
    ): LotteryComposer<[...TReturns, MethodReturn<"deleteApplication()void">]>;
  };

  /**
   * Makes a clear_state call to an existing instance of the Lottery smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(
    args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs
  ): LotteryComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(
    txn:
      | TransactionWithSigner
      | TransactionToSign
      | Transaction
      | Promise<SendTransactionResult>,
    defaultSender?: SendTransactionFrom
  ): LotteryComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(
    options?: SimulateOptions
  ): Promise<LotteryComposerSimulateResult<TReturns>>;
  /**
   * Executes the transaction group and returns the results
   */
  execute(
    sendParams?: AppClientComposeExecuteParams
  ): Promise<LotteryComposerResults<TReturns>>;
};
export type SimulateOptions = Omit<
  ConstructorParameters<typeof modelsv2.SimulateRequest>[0],
  "txnGroups"
>;
export type LotteryComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns;
  methodResults: ABIResult[];
  simulateResponse: modelsv2.SimulateResponse;
};
export type LotteryComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns;
  groupId: string;
  txIds: string[];
  transactions: Transaction[];
};
