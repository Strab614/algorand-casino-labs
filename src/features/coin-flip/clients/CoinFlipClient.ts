/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from "@algorandfoundation/algokit-utils";
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from "@algorandfoundation/algokit-utils/types/app";
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from "@algorandfoundation/algokit-utils/types/app-client";
import type { AppSpec } from "@algorandfoundation/algokit-utils/types/app-spec";
import type {
  SendTransactionResult,
  TransactionToSign,
  SendTransactionFrom,
  SendTransactionParams,
} from "@algorandfoundation/algokit-utils/types/transaction";
import type { ABIResult, TransactionWithSigner } from "algosdk";
import {
  Algodv2,
  OnApplicationComplete,
  Transaction,
  AtomicTransactionComposer,
  modelsv2,
} from "algosdk";
export const APP_SPEC: any = {
  hints: {
    "setManager(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getManager()address": {
      call_config: {
        no_op: "CALL",
      },
    },
    "createApplication(string,uint64,uint64,uint64,uint64,uint64)void": {
      call_config: {
        no_op: "CREATE",
      },
    },
    "updateApplication()void": {
      call_config: {
        update_application: "CALL",
      },
    },
    "deleteApplication()void": {
      call_config: {
        delete_application: "CALL",
      },
    },
    "bootstrap()void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "getFees()void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "addPrizePool(axfer)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "createGame(axfer,pay,uint64)uint64": {
      call_config: {
        no_op: "CALL",
      },
    },
    "cancelGame(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "completeGame(address)void": {
      call_config: {
        no_op: "CALL",
      },
    },
  },
  bare_call_config: {
    no_op: "NEVER",
    opt_in: "NEVER",
    close_out: "NEVER",
    update_application: "NEVER",
    delete_application: "NEVER",
  },
  schema: {
    local: {
      declared: {},
      reserved: {},
    },
    global: {
      declared: {
        _manager: {
          type: "bytes",
          key: "manager",
        },
        name: {
          type: "bytes",
          key: "name",
        },
        assetId: {
          type: "uint64",
          key: "assetId",
        },
        beaconAppId: {
          type: "uint64",
          key: "beaconAppId",
        },
        feePercent: {
          type: "uint64",
          key: "feePercent",
        },
        minBet: {
          type: "uint64",
          key: "minBet",
        },
        maxBet: {
          type: "uint64",
          key: "maxBet",
        },
        fees: {
          type: "uint64",
          key: "fees",
        },
        prizePool: {
          type: "uint64",
          key: "prizePool",
        },
        totalGames: {
          type: "uint64",
          key: "totalGames",
        },
        totalCancelled: {
          type: "uint64",
          key: "totalCancelled",
        },
        totalHeads: {
          type: "uint64",
          key: "totalHeads",
        },
        totalWagered: {
          type: "uint64",
          key: "totalWagered",
        },
        totalWon: {
          type: "uint64",
          key: "totalWon",
        },
      },
      reserved: {},
    },
  },
  state: {
    global: {
      num_byte_slices: 2,
      num_uints: 12,
    },
    local: {
      num_byte_slices: 0,
      num_uints: 0,
    },
  },
  source: {
    approval:
      "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjk2LjIKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uICpjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gc2V0TWFuYWdlcihhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9zZXRNYW5hZ2VyOgoJLy8gbmV3TWFuYWdlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChuZXdNYW5hZ2VyKSBmb3Igc2V0TWFuYWdlciBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzZXRNYW5hZ2VyKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBzZXRNYW5hZ2VyCglpbnQgMQoJcmV0dXJuCgovLyBzZXRNYW5hZ2VyKG5ld01hbmFnZXI6IEFkZHJlc3MpOiB2b2lkCi8vCi8vCi8vIENoYW5nZXMgd2hpY2ggYWRkcmVzcyBjYW4gbWFuYWdlIHRoaXMgY29udHJhY3QKLy8KLy8gQHBhcmFtIG5ld01hbmFnZXIgdGhlIEFkZHJlc3MgdGhhdCB3aWxsIGJlIGFibGUgdG8gbWFuYWdlIHRoZSBjb250cmFjdApzZXRNYW5hZ2VyOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTWFuYWdhYmxlLmFsZ28udHM6MjIKCS8vIG9sZE1hbmFnZXIgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCWZyYW1lX2J1cnkgMCAvLyBvbGRNYW5hZ2VyOiBhZGRyZXNzCgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9NYW5hZ2FibGUuYWxnby50czoyNQoJLy8gdGhpcy5fbWFuYWdlci5leGlzdHMKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6ICppZjBfZW5kCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTWFuYWdhYmxlLmFsZ28udHM6MjYKCS8vIHZlcmlmeVR4bih0aGlzLnR4biwgewoJLy8gICAgICAgICBzZW5kZXI6IHRoaXMuX21hbmFnZXIudmFsdWUsCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJ0aGlzLnR4biIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLl9tYW5hZ2VyLnZhbHVlIn0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9NYW5hZ2FibGUuYWxnby50czozMAoJLy8gYXNzZXJ0KHRoaXMuX21hbmFnZXIudmFsdWUgIT09IG5ld01hbmFnZXIpCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIG5ld01hbmFnZXI6IEFkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTWFuYWdhYmxlLmFsZ28udHM6MzIKCS8vIG9sZE1hbmFnZXIgPSB0aGlzLl9tYW5hZ2VyLnZhbHVlCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfYnVyeSAwIC8vIG9sZE1hbmFnZXI6IGFkZHJlc3MKCippZjBfZW5kOgoJLy8gY29udHJhY3RzL01hbmFnYWJsZS5hbGdvLnRzOjM1CgkvLyB0aGlzLl9tYW5hZ2VyLnZhbHVlID0gbmV3TWFuYWdlcgoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJZnJhbWVfZGlnIC0xIC8vIG5ld01hbmFnZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL01hbmFnYWJsZS5hbGdvLnRzOjM3CgkvLyB0aGlzLlNldE1hbmFnZXJFdmVudC5sb2coewoJLy8gICAgICAgb2xkTWFuYWdlcjogb2xkTWFuYWdlciwKCS8vICAgICAgIG5ld01hbmFnZXI6IG5ld01hbmFnZXIsCgkvLyAgICAgfSkKCWJ5dGUgMHgwNDJkNmI2YyAvLyBTZXRNYW5hZ2VyRXZlbnQoYWRkcmVzcyxhZGRyZXNzKQoJZnJhbWVfZGlnIDAgLy8gb2xkTWFuYWdlcjogYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIG5ld01hbmFnZXI6IEFkZHJlc3MKCWNvbmNhdAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gZ2V0TWFuYWdlcigpYWRkcmVzcwoqYWJpX3JvdXRlX2dldE1hbmFnZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0TWFuYWdlcigpYWRkcmVzcwoJY2FsbHN1YiBnZXRNYW5hZ2VyCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TWFuYWdlcigpOiBBZGRyZXNzCi8vCi8vCi8vIFJldHVybnMgdGhlIGN1cnJlbnQgbWFuYWdlcgovLwovLyBAcmV0dXJucyBUaGUgY3VycmVudCBtYW5hZ2VycyBBZGRyZXNzCmdldE1hbmFnZXI6Cglwcm90byAwIDEKCgkvLyBjb250cmFjdHMvTWFuYWdhYmxlLmFsZ28udHM6NTEKCS8vIHJldHVybiB0aGlzLl9tYW5hZ2VyLnZhbHVlOwoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gaXNNYW5hZ2VyKCk6IGJvb2xlYW4KaXNNYW5hZ2VyOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL01hbmFnYWJsZS5hbGdvLnRzOjU1CgkvLyByZXR1cm4gdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLmdldE1hbmFnZXIoKTsKCXR4biBTZW5kZXIKCWNhbGxzdWIgZ2V0TWFuYWdlcgoJPT0KCXJldHN1YgoKLy8gZGVsZXRlR2FtZShhZGRyZXNzOiBBZGRyZXNzKTogdm9pZAovLwovLwovLyBEZWxldGUgYSBnaXZlbiBib3ggYW5kIHNlbmQgdXNlciBiYWNrIHRoZSBjb3N0IChtaW51cyBmZWVzIGFsZ29zIGlmIGNhbGxlZCBieSBtYW5hZ2VyKQovLyBAcmV0dXJucyB2b2lkLCB0aHJvd3Mgb24gZXJyb3IKZGVsZXRlR2FtZToKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6ODUKCS8vIGFtb3VudDogdWludDY0ID0gQk9YX1NUT1JBR0VfQ09TVAoJaW50IDM0OTAwCglmcmFtZV9idXJ5IDAgLy8gYW1vdW50OiB1aW50NjQKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6ODkKCS8vIHRoaXMudHhuLnNlbmRlciAhPT0gYWRkcmVzcwoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCSE9CglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6OTAKCS8vIGFtb3VudCAtPSAzMDAwCglmcmFtZV9kaWcgMCAvLyBhbW91bnQ6IHVpbnQ2NAoJaW50IDMwMDAKCS0KCWZyYW1lX2J1cnkgMCAvLyBhbW91bnQ6IHVpbnQ2NAoKKmlmMV9lbmQ6CgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czo5NAoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgcmVjZWl2ZXI6IGFkZHJlc3MsCgkvLyAgICAgICBhbW91bnQ6IGFtb3VudCwKCS8vICAgICAgIGZlZTogMCwKCS8vICAgICAgIG5vdGU6ICdib3ggc3RvcmFnZSBjb3N0IHJlZnVuZCcsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czo5NQoJLy8gcmVjZWl2ZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6OTYKCS8vIGFtb3VudDogYW1vdW50CglmcmFtZV9kaWcgMCAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czo5NwoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czo5OAoJLy8gbm90ZTogJ2JveCBzdG9yYWdlIGNvc3QgcmVmdW5kJwoJYnl0ZSAweDYyNmY3ODIwNzM3NDZmNzI2MTY3NjUyMDYzNmY3Mzc0MjA3MjY1NjY3NTZlNjQgLy8gImJveCBzdG9yYWdlIGNvc3QgcmVmdW5kIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjEwMgoJLy8gdGhpcy5jb2luRmxpcEdhbWUoYWRkcmVzcykuZGVsZXRlKCkKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglib3hfZGVsCglyZXRzdWIKCi8vIGdldEJlYWNvblJhbmRvbW5lc3MoYmVhY29uQXBwSWQ6IEFwcElELCBhZGRyZXNzOiBBZGRyZXNzLCByb3VuZDogdWludDY0KTogYnl0ZXMKLy8KLy8gVXNlZCB0byBjYWxsIHJhbmRvbW5lc3MgYmVhY29uIGZvciBnYW1lCi8vIEBwYXJhbSBiZWFjb25BcHBJZCB0aGUgYXBwIGlkIG9mIHRoZSBiZWFjb24gdG8gdXNlCi8vIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzIHRvIHVzZQovLyBAcGFyYW0gY29tbWl0bWVudFJvdW5kIHRoZSByb3VuZCB0byByZWFkIGRhdGEgZm9yCi8vIEByZXR1cm5zIGJ5dGVzMzIgdHlwZSBjb250YWluaW5nIHJhbmRvbSBidWZmZXIKZ2V0QmVhY29uUmFuZG9tbmVzczoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTEzCgkvLyBiOiBieXRlcyA9IHNlbmRNZXRob2RDYWxsPFt1aW50NjQsIGJ5dGVzXSwgYnl0ZXM+KHsKCS8vICAgICAgIG5hbWU6ICdtdXN0X2dldCcsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbcm91bmQsIHJhd0J5dGVzKGFkZHJlc3MpXSwgLy8gbm8gcGFyYW0gdG8gYmUgaGFzaGVkCgkvLyAgICAgICBhcHBsaWNhdGlvbklEOiBiZWFjb25BcHBJZCwKCS8vICAgICAgIGZlZTogMCwKCS8vICAgICAgIG9uQ29tcGxldGlvbjogT25Db21wbGV0aW9uLk5vT3AsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgIm11c3RfZ2V0KHVpbnQ2NCxieXRlW10pYnl0ZVtdIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxMTUKCS8vIG1ldGhvZEFyZ3M6IFtyb3VuZCwgcmF3Qnl0ZXMoYWRkcmVzcyldCglmcmFtZV9kaWcgLTMgLy8gcm91bmQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxMTYKCS8vIGFwcGxpY2F0aW9uSUQ6IGJlYWNvbkFwcElkCglmcmFtZV9kaWcgLTEgLy8gYmVhY29uQXBwSWQ6IEFwcElECglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxMTcKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTE4CgkvLyBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5Ob09wCglpbnQgMCAvLyBOb09wCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCWl0eG4gTnVtTG9ncwoJaW50IDEKCS0KCWl0eG5hcyBMb2dzCglleHRyYWN0IDQgMAoJZXh0cmFjdCAyIDAKCWZyYW1lX2J1cnkgMCAvLyBiOiBieXRlcwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjEyMQoJLy8gcmV0dXJuIGI7CglmcmFtZV9kaWcgMCAvLyBiOiBieXRlcwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBtYXhCZXQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIG1pbkJldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gZmVlUGVyY2VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gYmVhY29uQXBwSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGFzc2V0SWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKG5hbWU6IHN0cmluZywgYXNzZXRJZDogQXNzZXRJRCwgYmVhY29uQXBwSWQ6IEFwcElELCBmZWVQZXJjZW50OiB1aW50NjQsIG1pbkJldDogdWludDY0LCBtYXhCZXQ6IHVpbnQ2NCk6IHZvaWQKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byA2IDAKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxMzMKCS8vIHRoaXMuc2V0TWFuYWdlcih0aGlzLmFwcC5jcmVhdG9yKQoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljYWxsc3ViIHNldE1hbmFnZXIKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxMzUKCS8vIHRoaXMubmFtZS52YWx1ZSA9IG5hbWUKCWJ5dGUgMHg2ZTYxNmQ2NSAvLyAibmFtZSIKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjEzNgoJLy8gdGhpcy5hc3NldElkLnZhbHVlID0gYXNzZXRJZAoJYnl0ZSAweDYxNzM3MzY1NzQ0OTY0IC8vICJhc3NldElkIgoJZnJhbWVfZGlnIC0yIC8vIGFzc2V0SWQ6IEFzc2V0SUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTM3CgkvLyB0aGlzLmJlYWNvbkFwcElkLnZhbHVlID0gYmVhY29uQXBwSWQKCWJ5dGUgMHg2MjY1NjE2MzZmNmU0MTcwNzA0OTY0IC8vICJiZWFjb25BcHBJZCIKCWZyYW1lX2RpZyAtMyAvLyBiZWFjb25BcHBJZDogQXBwSUQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTM4CgkvLyB0aGlzLmZlZVBlcmNlbnQudmFsdWUgPSBmZWVQZXJjZW50CglieXRlIDB4NjY2NTY1NTA2NTcyNjM2NTZlNzQgLy8gImZlZVBlcmNlbnQiCglmcmFtZV9kaWcgLTQgLy8gZmVlUGVyY2VudDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjEzOQoJLy8gdGhpcy5taW5CZXQudmFsdWUgPSBtaW5CZXQKCWJ5dGUgMHg2ZDY5NmU0MjY1NzQgLy8gIm1pbkJldCIKCWZyYW1lX2RpZyAtNSAvLyBtaW5CZXQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNDAKCS8vIHRoaXMubWF4QmV0LnZhbHVlID0gbWF4QmV0CglieXRlIDB4NmQ2MTc4NDI2NTc0IC8vICJtYXhCZXQiCglmcmFtZV9kaWcgLTYgLy8gbWF4QmV0OiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTQzCgkvLyB0aGlzLmZlZXMudmFsdWUgPSAwCglieXRlIDB4NjY2NTY1NzMgLy8gImZlZXMiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNDQKCS8vIHRoaXMucHJpemVQb29sLnZhbHVlID0gMAoJYnl0ZSAweDcwNzI2OTdhNjU1MDZmNmY2YyAvLyAicHJpemVQb29sIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTQ3CgkvLyB0aGlzLnRvdGFsR2FtZXMudmFsdWUgPSAwCglieXRlIDB4NzQ2Zjc0NjE2YzQ3NjE2ZDY1NzMgLy8gInRvdGFsR2FtZXMiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNDgKCS8vIHRoaXMudG90YWxDYW5jZWxsZWQudmFsdWUgPSAwCglieXRlIDB4NzQ2Zjc0NjE2YzQzNjE2ZTYzNjU2YzZjNjU2NCAvLyAidG90YWxDYW5jZWxsZWQiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNDkKCS8vIHRoaXMudG90YWxIZWFkcy52YWx1ZSA9IDAKCWJ5dGUgMHg3NDZmNzQ2MTZjNDg2NTYxNjQ3MyAvLyAidG90YWxIZWFkcyIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjE1MAoJLy8gdGhpcy50b3RhbFdhZ2VyZWQudmFsdWUgPSAwCglieXRlIDB4NzQ2Zjc0NjE2YzU3NjE2NzY1NzI2NTY0IC8vICJ0b3RhbFdhZ2VyZWQiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNTEKCS8vIHRoaXMudG90YWxXb24udmFsdWUgPSAwCglieXRlIDB4NzQ2Zjc0NjE2YzU3NmY2ZSAvLyAidG90YWxXb24iCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNTQKCS8vIHRoaXMuQ3JlYXRlRXZlbnQubG9nKHsgbmFtZTogbmFtZSB9KQoJYnl0ZSAweDMwMDc4YzYxIC8vIENyZWF0ZUV2ZW50KHN0cmluZykKCWJ5dGUgMHggLy8gaW5pdGlhbCBoZWFkCglieXRlIDB4IC8vIGluaXRpYWwgdGFpbAoJYnl0ZSAweDAwMDIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIG5hbWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWNvbmNhdAoJbG9nCglyZXRzdWIKCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIHVwZGF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIHVwZGF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyB1cGRhdGVBcHBsaWNhdGlvbigpOiB2b2lkCnVwZGF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTU5CgkvLyBhc3NlcnQodGhpcy5pc01hbmFnZXIoKSwgJ29ubHkgdGhlIG1hbmFnZXIgY2FuIGNhbGwgdGhpcyBtZXRob2QnKQoJY2FsbHN1YiBpc01hbmFnZXIKCgkvLyBvbmx5IHRoZSBtYW5hZ2VyIGNhbiBjYWxsIHRoaXMgbWV0aG9kCglhc3NlcnQKCXJldHN1YgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgZGVsZXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKZGVsZXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNjQKCS8vIGFzc2VydCh0aGlzLmlzTWFuYWdlcigpLCAnb25seSB0aGUgbWFuYWdlciBjYW4gY2FsbCB0aGlzIG1ldGhvZCcpCgljYWxsc3ViIGlzTWFuYWdlcgoKCS8vIG9ubHkgdGhlIG1hbmFnZXIgY2FuIGNhbGwgdGhpcyBtZXRob2QKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjE2NwoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgeGZlckFzc2V0OiB0aGlzLmFzc2V0SWQudmFsdWUsCgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmdldE1hbmFnZXIoKSwKCS8vICAgICAgIGFzc2V0QW1vdW50OiB0aGlzLnByaXplUG9vbC52YWx1ZSwKCS8vICAgICAgIG5vdGU6ICdwcml6ZSBwb29sJywKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTY4CgkvLyB4ZmVyQXNzZXQ6IHRoaXMuYXNzZXRJZC52YWx1ZQoJYnl0ZSAweDYxNzM3MzY1NzQ0OTY0IC8vICJhc3NldElkIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTY5CgkvLyBhc3NldFJlY2VpdmVyOiB0aGlzLmdldE1hbmFnZXIoKQoJY2FsbHN1YiBnZXRNYW5hZ2VyCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNzAKCS8vIGFzc2V0QW1vdW50OiB0aGlzLnByaXplUG9vbC52YWx1ZQoJYnl0ZSAweDcwNzI2OTdhNjU1MDZmNmY2YyAvLyAicHJpemVQb29sIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxNzEKCS8vIG5vdGU6ICdwcml6ZSBwb29sJwoJYnl0ZSAweDcwNzI2OTdhNjUyMDcwNmY2ZjZjIC8vICJwcml6ZSBwb29sIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBib290c3RyYXAoKXZvaWQKKmFiaV9yb3V0ZV9ib290c3RyYXA6CgkvLyBleGVjdXRlIGJvb3RzdHJhcCgpdm9pZAoJY2FsbHN1YiBib290c3RyYXAKCWludCAxCglyZXR1cm4KCi8vIGJvb3RzdHJhcCgpOiB2b2lkCi8vCi8vIEluaXRpYWxpYXNlIHRoZSBhcHAgYWZ0ZXIgY3JlYXRpb24KYm9vdHN0cmFwOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxODIKCS8vIGFzc2VydCh0aGlzLmlzTWFuYWdlcigpKQoJY2FsbHN1YiBpc01hbmFnZXIKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjE4NAoJLy8gYXNzZXRJZCA9IHRoaXMuYXNzZXRJZC52YWx1ZQoJYnl0ZSAweDYxNzM3MzY1NzQ0OTY0IC8vICJhc3NldElkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMCAvLyBhc3NldElkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoxODcKCS8vIGFzc2VydCghdGhpcy5hcHAuYWRkcmVzcy5pc09wdGVkSW5Ub0Fzc2V0KGFzc2V0SWQpLCAnaXMgbm90IG9wdGVkIGludG8gYXNzZXQnKQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAwIC8vIGFzc2V0SWQ6IHVpbnQ2NAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglzd2FwCglwb3AKCSEKCgkvLyBpcyBub3Qgb3B0ZWQgaW50byBhc3NldAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTg5CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgeGZlckFzc2V0OiBhc3NldElkLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjE5MAoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjE5MQoJLy8geGZlckFzc2V0OiBhc3NldElkCglmcmFtZV9kaWcgMCAvLyBhc3NldElkOiB1aW50NjQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MTkyCgkvLyBhc3NldEFtb3VudDogMAoJaW50IDAKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGdldEZlZXMoKXZvaWQKKmFiaV9yb3V0ZV9nZXRGZWVzOgoJLy8gZXhlY3V0ZSBnZXRGZWVzKCl2b2lkCgljYWxsc3ViIGdldEZlZXMKCWludCAxCglyZXR1cm4KCi8vIGdldEZlZXMoKTogdm9pZAovLwovLyBBbGxvd3MgbWFuYWdlciB0byBjbGFpbSB0aGUgZmVlcwpnZXRGZWVzOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjAwCgkvLyBhc3NlcnQodGhpcy5pc01hbmFnZXIoKSwgJ29ubHkgbWFuYWdlciBjYW4gY2FsbCB0aGlzJykKCWNhbGxzdWIgaXNNYW5hZ2VyCgoJLy8gb25seSBtYW5hZ2VyIGNhbiBjYWxsIHRoaXMKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIwMQoJLy8gYXNzZXJ0KHRoaXMuZmVlcy52YWx1ZSA+IDAsICdmZWVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKQoJYnl0ZSAweDY2NjU2NTczIC8vICJmZWVzIgoJYXBwX2dsb2JhbF9nZXQKCWludCAwCgk+CgoJLy8gZmVlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwCglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyMDQKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZ2V0TWFuYWdlcigpLAoJLy8gICAgICAgeGZlckFzc2V0OiB0aGlzLmFzc2V0SWQudmFsdWUsCgkvLyAgICAgICBhc3NldEFtb3VudDogdGhpcy5mZWVzLnZhbHVlLAoJLy8gICAgICAgbm90ZTogJ2ZlZXMnLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyMDUKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZ2V0TWFuYWdlcigpCgljYWxsc3ViIGdldE1hbmFnZXIKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIwNgoJLy8geGZlckFzc2V0OiB0aGlzLmFzc2V0SWQudmFsdWUKCWJ5dGUgMHg2MTczNzM2NTc0NDk2NCAvLyAiYXNzZXRJZCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIwNwoJLy8gYXNzZXRBbW91bnQ6IHRoaXMuZmVlcy52YWx1ZQoJYnl0ZSAweDY2NjU2NTczIC8vICJmZWVzIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyMDgKCS8vIG5vdGU6ICdmZWVzJwoJYnl0ZSAweDY2NjU2NTczIC8vICJmZWVzIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIxMgoJLy8gdGhpcy5mZWVzLnZhbHVlID0gMAoJYnl0ZSAweDY2NjU2NTczIC8vICJmZWVzIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGFkZFByaXplUG9vbChheGZlcil2b2lkCiphYmlfcm91dGVfYWRkUHJpemVQb29sOgoJLy8gYXhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCAwIChheGZlcikgZm9yIGFkZFByaXplUG9vbCBtdXN0IGJlIGEgYXhmZXIgdHJhbnNhY3Rpb24KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWRkUHJpemVQb29sKGF4ZmVyKXZvaWQKCWNhbGxzdWIgYWRkUHJpemVQb29sCglpbnQgMQoJcmV0dXJuCgovLyBhZGRQcml6ZVBvb2woYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4pOiB2b2lkCi8vCi8vIEFsbG93cyBwcml6ZSBwb29sIHRvIGJlIGFkZGVkLCBjYWxsYWJsZSBieSBhbnlvbmUKYWRkUHJpemVQb29sOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjIwCgkvLyB2ZXJpZnlUeG4oYXhmZXIsIHsKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHhmZXJBc3NldDogdGhpcy5hc3NldElkLnZhbHVlLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsKCS8vICAgICAgICAgZ3JlYXRlclRoYW5FcXVhbFRvOiAwLAoJLy8gICAgICAgfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBTZW5kZXIKCXR4biBTZW5kZXIKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJheGZlciIsImZpZWxkIjoic2VuZGVyIiwiZXhwZWN0ZWQiOiJ0aGlzLnR4bi5zZW5kZXIifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJheGZlciIsImZpZWxkIjoiYXNzZXRSZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgeGZlckFzc2V0CglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFhmZXJBc3NldAoJYnl0ZSAweDYxNzM3MzY1NzQ0OTY0IC8vICJhc3NldElkIgoJYXBwX2dsb2JhbF9nZXQKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJheGZlciIsImZpZWxkIjoieGZlckFzc2V0IiwiZXhwZWN0ZWQiOiJ0aGlzLmFzc2V0SWQudmFsdWUifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglpbnQgMAoJPj0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJhc3NldEFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuRXF1YWxUbyIsImV4cGVjdGVkIjoiPj0wIn0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIyOQoJLy8gdGhpcy5wcml6ZVBvb2wudmFsdWUgKz0gYXhmZXIuYXNzZXRBbW91bnQKCWJ5dGUgMHg3MDcyNjk3YTY1NTA2ZjZmNmMgLy8gInByaXplUG9vbCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CgkrCglieXRlIDB4NzA3MjY5N2E2NTUwNmY2ZjZjIC8vICJwcml6ZVBvb2wiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjIzMQoJLy8gdGhpcy5BZGRQcml6ZVBvb2xFdmVudC5sb2coewoJLy8gICAgICAgYWRkcmVzczogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgYW1vdW50OiBheGZlci5hc3NldEFtb3VudCwKCS8vICAgICAgIHRvdGFsOiB0aGlzLnByaXplUG9vbC52YWx1ZSwKCS8vICAgICB9KQoJYnl0ZSAweDA2ZDFhODFhIC8vIEFkZFByaXplUG9vbEV2ZW50KGFkZHJlc3MsdWludDY0LHVpbnQ2NCkKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDcwNzI2OTdhNjU1MDZmNmY2YyAvLyAicHJpemVQb29sIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gY3JlYXRlR2FtZShheGZlcixwYXksdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2NyZWF0ZUdhbWU6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGhlYWRzOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBib3hGZWVUeG46IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDEgKGJveEZlZVR4bikgZm9yIGNyZWF0ZUdhbWUgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gYXhmZXI6IGF4ZmVyCgl0eG4gR3JvdXBJbmRleAoJaW50IDIKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBheGZlcgoJPT0KCgkvLyBhcmd1bWVudCAyIChheGZlcikgZm9yIGNyZWF0ZUdhbWUgbXVzdCBiZSBhIGF4ZmVyIHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBleGVjdXRlIGNyZWF0ZUdhbWUoYXhmZXIscGF5LHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgY3JlYXRlR2FtZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUdhbWUoYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4sIGJveEZlZVR4bjogUGF5VHhuLCBoZWFkczogdWludDY0KTogdWludDY0Ci8vCi8vIENyZWF0ZXMgYSBuZXcgZ2FtZSBmb3IgdGhlIGNhbGxlcgpjcmVhdGVHYW1lOgoJcHJvdG8gMyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjI0MwoJLy8gYXNzZXJ0KCF0aGlzLmNvaW5GbGlwR2FtZSh0aGlzLnR4bi5zZW5kZXIpLmV4aXN0cywgJ211c3Qgbm90IGhhdmUgYSBnYW1lIGluIHByb2dyZXNzJykKCXR4biBTZW5kZXIKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoKCS8vIG11c3Qgbm90IGhhdmUgYSBnYW1lIGluIHByb2dyZXNzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyNDYKCS8vIHZlcmlmeVBheVR4bihib3hGZWVUeG4sIHsKCS8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCAvLyBtdXN0IGdvIHRvIHRoaXMgd2FsbGV0IGFkZHJlc3MKCS8vICAgICAgIGFtb3VudDogewoJLy8gICAgICAgICBncmVhdGVyVGhhbkVxdWFsVG86IEJPWF9TVE9SQUdFX0NPU1QsIC8vIG11c3QgYXQgbGVhc3QgY292ZXIgdGhlIG1iciBpbmNyZWFzZQoJLy8gICAgICAgfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTIgLy8gYm94RmVlVHhuOiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImJveEZlZVR4biIsImZpZWxkIjoicmVjZWl2ZXIiLCJleHBlY3RlZCI6InRoaXMuYXBwLmFkZHJlc3MifQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGJveEZlZVR4bjogUGF5VHhuCglndHhucyBBbW91bnQKCWludCAzNDkwMAoJPj0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImJveEZlZVR4biIsImZpZWxkIjoiYW1vdW50IiwiY29uZGl0aW9uIjoiZ3JlYXRlclRoYW5FcXVhbFRvIiwiZXhwZWN0ZWQiOiI+PUJPWF9TVE9SQUdFX0NPU1QifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjUzCgkvLyB0b3RhbEF4ZmVyQW1vdW50ID0gYXhmZXIuYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2J1cnkgMCAvLyB0b3RhbEF4ZmVyQW1vdW50OiB1aW50NjQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyNTUKCS8vIGFzc2VydCh0b3RhbEF4ZmVyQW1vdW50ID49IHRoaXMubWluQmV0LnZhbHVlLCAnbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluQmV0JykKCWZyYW1lX2RpZyAwIC8vIHRvdGFsQXhmZXJBbW91bnQ6IHVpbnQ2NAoJYnl0ZSAweDZkNjk2ZTQyNjU3NCAvLyAibWluQmV0IgoJYXBwX2dsb2JhbF9nZXQKCT49CgoJLy8gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluQmV0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyNTYKCS8vIGFzc2VydCh0b3RhbEF4ZmVyQW1vdW50IDw9IHRoaXMubWF4QmV0LnZhbHVlLCAnbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4QmV0JykKCWZyYW1lX2RpZyAwIC8vIHRvdGFsQXhmZXJBbW91bnQ6IHVpbnQ2NAoJYnl0ZSAweDZkNjE3ODQyNjU3NCAvLyAibWF4QmV0IgoJYXBwX2dsb2JhbF9nZXQKCTw9CgoJLy8gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4QmV0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyNTgKCS8vIHZlcmlmeUFzc2V0VHJhbnNmZXJUeG4oYXhmZXIsIHsKCS8vICAgICAgIHNlbmRlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIHhmZXJBc3NldDogdGhpcy5hc3NldElkLnZhbHVlLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IHsKCS8vICAgICAgICAgZ3JlYXRlclRoYW46IDAsCgkvLyAgICAgICAgIGxlc3NUaGFuRXF1YWxUbzogdGhpcy5wcml6ZVBvb2wudmFsdWUgLyAyLCAvLyBjYW5ub3QgYmV0IG1vcmUgdGhhbiBoYWxmIHRoZSBwcml6ZSBwb29sCgkvLyAgICAgICB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIFNlbmRlcgoJdHhuIFNlbmRlcgoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJzZW5kZXIiLCJleHBlY3RlZCI6InRoaXMudHhuLnNlbmRlciJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIGF4ZmVyOiBBc3NldFRyYW5zZmVyVHhuCglndHhucyBBc3NldFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJhc3NldFJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgWGZlckFzc2V0CglieXRlIDB4NjE3MzczNjU3NDQ5NjQgLy8gImFzc2V0SWQiCglhcHBfZ2xvYmFsX2dldAoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6ImF4ZmVyIiwiZmllbGQiOiJ4ZmVyQXNzZXQiLCJleHBlY3RlZCI6InRoaXMuYXNzZXRJZC52YWx1ZSJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBheGZlcjogQXNzZXRUcmFuc2ZlclR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWludCAwCgk+CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJheGZlciIsImZpZWxkIjoiYXNzZXRBbW91bnQiLCJjb25kaXRpb24iOiJncmVhdGVyVGhhbiIsImV4cGVjdGVkIjoiPjAifQoJYXNzZXJ0CglmcmFtZV9kaWcgLTEgLy8gYXhmZXI6IEFzc2V0VHJhbnNmZXJUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglieXRlIDB4NzA3MjY5N2E2NTUwNmY2ZjZjIC8vICJwcml6ZVBvb2wiCglhcHBfZ2xvYmFsX2dldAoJaW50IDIKCS8KCTw9CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJheGZlciIsImZpZWxkIjoiYXNzZXRBbW91bnQiLCJjb25kaXRpb24iOiJsZXNzVGhhbkVxdWFsVG8iLCJleHBlY3RlZCI6Ijw9dGhpcy5wcml6ZVBvb2wudmFsdWUgLyAyIn0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjI2OAoJLy8gZmVlOiB1aW50NjQgPSAodG90YWxBeGZlckFtb3VudCAqIHRoaXMuZmVlUGVyY2VudC52YWx1ZSkgLyAxMDAKCWZyYW1lX2RpZyAwIC8vIHRvdGFsQXhmZXJBbW91bnQ6IHVpbnQ2NAoJYnl0ZSAweDY2NjU2NTUwNjU3MjYzNjU2ZTc0IC8vICJmZWVQZXJjZW50IgoJYXBwX2dsb2JhbF9nZXQKCSoKCWludCAxMDAKCS8KCWZyYW1lX2J1cnkgMSAvLyBmZWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjI2OQoJLy8gd2FnZXI6IHVpbnQ2NCA9IHRvdGFsQXhmZXJBbW91bnQgLSBmZWUKCWZyYW1lX2RpZyAwIC8vIHRvdGFsQXhmZXJBbW91bnQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gZmVlOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMiAvLyB3YWdlcjogdWludDY0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjcxCgkvLyBjZmc6IENvaW5GbGlwR2FtZSA9IHsKCS8vICAgICAgIHdhZ2VyOiB3YWdlciwKCS8vICAgICAgIGhlYWRzOiBoZWFkcywKCS8vICAgICAgIGNvbW1pdG1lbnRSb3VuZDogZ2xvYmFscy5yb3VuZCArIE9SQUNMRV9ST1VORF9HQVAsCgkvLyAgICAgfQoJZnJhbWVfZGlnIDIgLy8gd2FnZXI6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0zIC8vIGhlYWRzOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZ2xvYmFsIFJvdW5kCglpbnQgMQoJKwoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDMgLy8gY2ZnOiBDb2luRmxpcEdhbWUKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyNzgKCS8vIHRoaXMuY29pbkZsaXBHYW1lKHRoaXMudHhuLnNlbmRlcikudmFsdWUgPSBjZmcKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAzIC8vIGNmZzogQ29pbkZsaXBHYW1lCglib3hfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjgwCgkvLyB0aGlzLnByaXplUG9vbC52YWx1ZSArPSBjZmcud2FnZXIKCWJ5dGUgMHg3MDcyNjk3YTY1NTA2ZjZmNmMgLy8gInByaXplUG9vbCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMyAvLyBjZmc6IENvaW5GbGlwR2FtZQoJZXh0cmFjdCAwIDgKCWJ0b2kKCSsKCWJ5dGUgMHg3MDcyNjk3YTY1NTA2ZjZmNmMgLy8gInByaXplUG9vbCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MjgyCgkvLyB0aGlzLmZlZXMudmFsdWUgKz0gZmVlCglieXRlIDB4NjY2NTY1NzMgLy8gImZlZXMiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDEgLy8gZmVlOiB1aW50NjQKCSsKCWJ5dGUgMHg2NjY1NjU3MyAvLyAiZmVlcyIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6Mjg0CgkvLyB0aGlzLnRvdGFsV2FnZXJlZC52YWx1ZSArPSBjZmcud2FnZXIKCWJ5dGUgMHg3NDZmNzQ2MTZjNTc2MTY3NjU3MjY1NjQgLy8gInRvdGFsV2FnZXJlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgMyAvLyBjZmc6IENvaW5GbGlwR2FtZQoJZXh0cmFjdCAwIDgKCWJ0b2kKCSsKCWJ5dGUgMHg3NDZmNzQ2MTZjNTc2MTY3NjU3MjY1NjQgLy8gInRvdGFsV2FnZXJlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6Mjg3CgkvLyB0aGlzLkNyZWF0ZUdhbWVFdmVudC5sb2coewoJLy8gICAgICAgYWRkcmVzczogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgd2FnZXI6IGNmZy53YWdlciwKCS8vICAgICAgIGhlYWRzOiBjZmcuaGVhZHMsCgkvLyAgICAgICBjb21taXRtZW50Um91bmQ6IGdsb2JhbHMucm91bmQgKyBPUkFDTEVfUk9VTkRfR0FQLAoJLy8gICAgIH0pCglieXRlIDB4Y2E1MjQzMGQgLy8gQ3JlYXRlR2FtZUV2ZW50KGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMyAvLyBjZmc6IENvaW5GbGlwR2FtZQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJZ2xvYmFsIFJvdW5kCglpbnQgMQoJKwoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgMyAvLyBjZmc6IENvaW5GbGlwR2FtZQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY29uY2F0Cglsb2cKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czoyOTQKCS8vIHJldHVybiBjZmcuY29tbWl0bWVudFJvdW5kOwoJZnJhbWVfZGlnIDMgLy8gY2ZnOiBDb2luRmxpcEdhbWUKCWV4dHJhY3QgMTYgOAoJYnRvaQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gY2FuY2VsR2FtZShhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9jYW5jZWxHYW1lOgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgY2FuY2VsR2FtZSBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjYW5jZWxHYW1lKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjYW5jZWxHYW1lCglpbnQgMQoJcmV0dXJuCgovLyBjYW5jZWxHYW1lKGFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCi8vCi8vIEFsbG93cyB1c2VyIHRvIGNhbmNlbCB0aGUgZ2FtZSBhbmQgcmVxdWVzdCBhIHJlZnVuZCAoc2hvdWxkIGJlIGNhbGxhYmxlIGJ5IGFkbWluKQpjYW5jZWxHYW1lOgoJcHJvdG8gMSAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMwMgoJLy8gdmVyaWZ5VHhuKHRoaXMudHhuLCB7CgkvLyAgICAgICBzZW5kZXI6IHsgaW5jbHVkZWRJbjogW3RoaXMuZ2V0TWFuYWdlcigpLCBhZGRyZXNzXSB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCgl0eG4gU2VuZGVyCgljYWxsc3ViIGdldE1hbmFnZXIKCT09Cgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJPT0KCXx8CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOnsidHhuVGV4dCI6InRoaXMudHhuIn0sImZpZWxkIjoic2VuZGVyIiwiY29uZGl0aW9uIjoiaW5jbHVkZWRJbiIsImV4cGVjdGVkIjoiW3RoaXMuZ2V0TWFuYWdlcigpLCBhZGRyZXNzXSJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMDcKCS8vIGFzc2VydCh0aGlzLmNvaW5GbGlwR2FtZShhZGRyZXNzKS5leGlzdHMsICdtdXN0IGhhdmUgYSBnYW1lIGluIHByb2dyZXNzJykKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCgkvLyBtdXN0IGhhdmUgYSBnYW1lIGluIHByb2dyZXNzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMTAKCS8vIGNmZzogQ29pbkZsaXBHYW1lID0gdGhpcy5jb2luRmxpcEdhbWUoYWRkcmVzcykudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL2NmZwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMxMwoJLy8gZGVhZGxpbmU6IHVpbnQ2NCA9IGNmZy5jb21taXRtZW50Um91bmQgKyBPUkFDTEVfTUFYX1JPVU5EUwoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWludCAxNTEyCgkrCglmcmFtZV9idXJ5IDEgLy8gZGVhZGxpbmU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMxNQoJLy8gYXNzZXJ0KGdsb2JhbHMucm91bmQgPj0gZGVhZGxpbmUsICdvcmFjbGUgaXMgdW5hYmxlIHRvIHN0b3JlIHRoZSB2cmYgcmVzdWx0JykKCWdsb2JhbCBSb3VuZAoJZnJhbWVfZGlnIDEgLy8gZGVhZGxpbmU6IHVpbnQ2NAoJPj0KCgkvLyBvcmFjbGUgaXMgdW5hYmxlIHRvIHN0b3JlIHRoZSB2cmYgcmVzdWx0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMTgKCS8vIGFzc2V0UmVjZWl2ZXIgPSBhZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJZnJhbWVfYnVyeSAyIC8vIGFzc2V0UmVjZWl2ZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMTkKCS8vIGFzc2V0SWQgPSB0aGlzLmFzc2V0SWQudmFsdWUKCWJ5dGUgMHg2MTczNzM2NTc0NDk2NCAvLyAiYXNzZXRJZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDMgLy8gYXNzZXRJZDogdWludDY0CgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMyMgoJLy8gIWFkZHJlc3MuaXNPcHRlZEluVG9Bc3NldChhc3NldElkKQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWZyYW1lX2RpZyAzIC8vIGFzc2V0SWQ6IHVpbnQ2NAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglzd2FwCglwb3AKCSEKCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMjMKCS8vIGFzc2V0UmVjZWl2ZXIgPSB0aGlzLmdldE1hbmFnZXIoKQoJY2FsbHN1YiBnZXRNYW5hZ2VyCglmcmFtZV9idXJ5IDIgLy8gYXNzZXRSZWNlaXZlcjogYWRkcmVzcwoKKmlmMl9lbmQ6CgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMjYKCS8vIHNlbmRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGFzc2V0UmVjZWl2ZXIsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0SWQsCgkvLyAgICAgICBhc3NldEFtb3VudDogY2ZnLndhZ2VyLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgICAgbm90ZTogJ3dhZ2VyIHJlZnVuZCcsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMyNwoJLy8gYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIDIgLy8gYXNzZXRSZWNlaXZlcjogYWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzI4CgkvLyB4ZmVyQXNzZXQ6IGFzc2V0SWQKCWZyYW1lX2RpZyAzIC8vIGFzc2V0SWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMjkKCS8vIGFzc2V0QW1vdW50OiBjZmcud2FnZXIKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgMAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzMwCgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMzMQoJLy8gbm90ZTogJ3dhZ2VyIHJlZnVuZCcKCWJ5dGUgMHg3NzYxNjc2NTcyMjA3MjY1NjY3NTZlNjQgLy8gIndhZ2VyIHJlZnVuZCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozMzUKCS8vIHRoaXMucHJpemVQb29sLnZhbHVlIC09IGNmZy53YWdlcgoJYnl0ZSAweDcwNzI2OTdhNjU1MDZmNmY2YyAvLyAicHJpemVQb29sIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgMAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCgktCglieXRlIDB4NzA3MjY5N2E2NTUwNmY2ZjZjIC8vICJwcml6ZVBvb2wiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjMzNwoJLy8gdGhpcy50b3RhbENhbmNlbGxlZC52YWx1ZSArPSAxCglieXRlIDB4NzQ2Zjc0NjE2YzQzNjE2ZTYzNjU2YzZjNjU2NCAvLyAidG90YWxDYW5jZWxsZWQiCglhcHBfZ2xvYmFsX2dldAoJaW50IDEKCSsKCWJ5dGUgMHg3NDZmNzQ2MTZjNDM2MTZlNjM2NTZjNmM2NTY0IC8vICJ0b3RhbENhbmNlbGxlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzM5CgkvLyB0aGlzLkNhbmNlbEdhbWVFdmVudC5sb2coeyBhZGRyZXNzOiBhZGRyZXNzLCB3YWdlcjogY2ZnLndhZ2VyIH0pCglieXRlIDB4OGQ2Yzk5OTQgLy8gQ2FuY2VsR2FtZUV2ZW50KGFkZHJlc3MsdWludDY0KQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgMAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljb25jYXQKCWNvbmNhdAoJbG9nCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzQxCgkvLyB0aGlzLmRlbGV0ZUdhbWUoYWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCgljYWxsc3ViIGRlbGV0ZUdhbWUKCXJldHN1YgoKLy8gY29tcGxldGVHYW1lKGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX2NvbXBsZXRlR2FtZToKCS8vIGFkZHJlc3M6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoYWRkcmVzcykgZm9yIGNvbXBsZXRlR2FtZSBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBjb21wbGV0ZUdhbWUoYWRkcmVzcyl2b2lkCgljYWxsc3ViIGNvbXBsZXRlR2FtZQoJaW50IDEKCXJldHVybgoKLy8gY29tcGxldGVHYW1lKGFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCi8vCi8vIENvbXBsZXRlcyBhIGdhbWUgYnkgY2FsbGluZyB0aGUgYmVhY29uLCBkZXRlcm1pbmluZyB0aGUgcmVzdWx0IGFuZCBwYXlpbmcgb3V0IHRoZSB1c2VyCmNvbXBsZXRlR2FtZToKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDYKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNDkKCS8vIHZlcmlmeVR4bih0aGlzLnR4biwgewoJLy8gICAgICAgc2VuZGVyOiB7IGluY2x1ZGVkSW46IFt0aGlzLmdldE1hbmFnZXIoKSwgYWRkcmVzc10gfSwKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJY2FsbHN1YiBnZXRNYW5hZ2VyCgk9PQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCT09Cgl8fAoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjp7InR4blRleHQiOiJ0aGlzLnR4biJ9LCJmaWVsZCI6InNlbmRlciIsImNvbmRpdGlvbiI6ImluY2x1ZGVkSW4iLCJleHBlY3RlZCI6Ilt0aGlzLmdldE1hbmFnZXIoKSwgYWRkcmVzc10ifQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzU0CgkvLyBhc3NlcnQodGhpcy5jb2luRmxpcEdhbWUoYWRkcmVzcykuZXhpc3RzLCAnbXVzdCBoYXZlIGEgZ2FtZSBpbiBwcm9ncmVzcycpCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJYm94X2xlbgoJc3dhcAoJcG9wCgoJLy8gbXVzdCBoYXZlIGEgZ2FtZSBpbiBwcm9ncmVzcwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzU2CgkvLyBjZmc6IENvaW5GbGlwR2FtZSA9IHRoaXMuY29pbkZsaXBHYW1lKGFkZHJlc3MpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly9jZmcKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNTcKCS8vIGNvbW1pdG1lbnRSb3VuZCA9IGNmZy5jb21taXRtZW50Um91bmQKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgMTYgLy8gaGVhZE9mZnNldAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDEgLy8gY29tbWl0bWVudFJvdW5kOiB1aW50NjQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNTkKCS8vIGFzc2VydChnbG9iYWxzLnJvdW5kID49IGNvbW1pdG1lbnRSb3VuZCwgJ2NvbW1pdG1lbnQgcm91bmQgbXVzdCBiZSBoYXZlIGVsYXBzZWQnKQoJZ2xvYmFsIFJvdW5kCglmcmFtZV9kaWcgMSAvLyBjb21taXRtZW50Um91bmQ6IHVpbnQ2NAoJPj0KCgkvLyBjb21taXRtZW50IHJvdW5kIG11c3QgYmUgaGF2ZSBlbGFwc2VkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNjIKCS8vIHJhbmRvbW5lc3M6IGJ5dGVzID0gdGhpcy5nZXRCZWFjb25SYW5kb21uZXNzKHRoaXMuYmVhY29uQXBwSWQudmFsdWUsIGFkZHJlc3MsIGNmZy5jb21taXRtZW50Um91bmQpCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWJ5dGUgMHg2MjY1NjE2MzZmNmU0MTcwNzA0OTY0IC8vICJiZWFjb25BcHBJZCIKCWFwcF9nbG9iYWxfZ2V0CgljYWxsc3ViIGdldEJlYWNvblJhbmRvbW5lc3MKCWZyYW1lX2J1cnkgMiAvLyByYW5kb21uZXNzOiBieXRlcwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjM2NAoJLy8gaXNIZWFkczogYm9vbGVhbiA9IGdldGJpdChyYW5kb21uZXNzLCAwKSBhcyBib29sZWFuCglmcmFtZV9kaWcgMiAvLyByYW5kb21uZXNzOiBieXRlcwoJaW50IDAKCWdldGJpdAoJZnJhbWVfYnVyeSAzIC8vIGlzSGVhZHM6IGJvb2xlYW4KCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzY2CgkvLyBpc0hlYWRzCglmcmFtZV9kaWcgMyAvLyBpc0hlYWRzOiBib29sZWFuCglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzY4CgkvLyB0aGlzLnRvdGFsSGVhZHMudmFsdWUgKz0gMQoJYnl0ZSAweDc0NmY3NDYxNmM0ODY1NjE2NDczIC8vICJ0b3RhbEhlYWRzIgoJYXBwX2dsb2JhbF9nZXQKCWludCAxCgkrCglieXRlIDB4NzQ2Zjc0NjE2YzQ4NjU2MTY0NzMgLy8gInRvdGFsSGVhZHMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKKmlmM19lbmQ6CgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNzEKCS8vIHdpbm5lciA9IGlzSGVhZHMgJiYgY2ZnLmhlYWRzID09PSAxCglmcmFtZV9kaWcgMyAvLyBpc0hlYWRzOiBib29sZWFuCglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgOCAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWludCAxCgk9PQoJJiYKCipza2lwX2FuZDA6CglmcmFtZV9idXJ5IDQgLy8gd2lubmVyOiBib29sCgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzcyCgkvLyB3YWdlciA9IGNmZy53YWdlcgoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWludCAwCglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgNSAvLyB3YWdlcjogdWludDY0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzczCgkvLyB3b24gPSAwCglpbnQgMAoJZnJhbWVfYnVyeSA2IC8vIHdvbjogdWludDY0CgoJLy8gKmlmNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjM3NgoJLy8gd2lubmVyCglmcmFtZV9kaWcgNCAvLyB3aW5uZXI6IGJvb2wKCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozNzcKCS8vIHdvbiA9IHdhZ2VyICogMgoJZnJhbWVfZGlnIDUgLy8gd2FnZXI6IHVpbnQ2NAoJaW50IDIKCSoKCWZyYW1lX2J1cnkgNiAvLyB3b246IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjM3OQoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IHRoaXMuYXNzZXRJZC52YWx1ZSwKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogYWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHdvbiwKCS8vICAgICAgICAgbm90ZTogJ3dpbm5lciBwYXltZW50JywKCS8vICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozODAKCS8vIHhmZXJBc3NldDogdGhpcy5hc3NldElkLnZhbHVlCglieXRlIDB4NjE3MzczNjU3NDQ5NjQgLy8gImFzc2V0SWQiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozODEKCS8vIGFzc2V0UmVjZWl2ZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozODIKCS8vIGFzc2V0QW1vdW50OiB3b24KCWZyYW1lX2RpZyA2IC8vIHdvbjogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6MzgzCgkvLyBub3RlOiAnd2lubmVyIHBheW1lbnQnCglieXRlIDB4Nzc2OTZlNmU2NTcyMjA3MDYxNzk2ZDY1NmU3NCAvLyAid2lubmVyIHBheW1lbnQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL0NvaW5GbGlwLmFsZ28udHM6Mzg3CgkvLyB0aGlzLnByaXplUG9vbC52YWx1ZSAtPSB3b24KCWJ5dGUgMHg3MDcyNjk3YTY1NTA2ZjZmNmMgLy8gInByaXplUG9vbCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgNiAvLyB3b246IHVpbnQ2NAoJLQoJYnl0ZSAweDcwNzI2OTdhNjU1MDZmNmY2YyAvLyAicHJpemVQb29sIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozODkKCS8vIHRoaXMudG90YWxXb24udmFsdWUgKz0gd29uCglieXRlIDB4NzQ2Zjc0NjE2YzU3NmY2ZSAvLyAidG90YWxXb24iCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDYgLy8gd29uOiB1aW50NjQKCSsKCWJ5dGUgMHg3NDZmNzQ2MTZjNTc2ZjZlIC8vICJ0b3RhbFdvbiIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoqaWY0X2VuZDoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjM5MwoJLy8gdGhpcy50b3RhbEdhbWVzLnZhbHVlICs9IDEKCWJ5dGUgMHg3NDZmNzQ2MTZjNDc2MTZkNjU3MyAvLyAidG90YWxHYW1lcyIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMQoJKwoJYnl0ZSAweDc0NmY3NDYxNmM0NzYxNmQ2NTczIC8vICJ0b3RhbEdhbWVzIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvQ29pbkZsaXAuYWxnby50czozOTYKCS8vIHRoaXMuQ29tcGxldGVHYW1lRXZlbnQubG9nKHsKCS8vICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsCgkvLyAgICAgICB3YWdlcjogY2ZnLndhZ2VyLAoJLy8gICAgICAgd29uOiB3b24sCgkvLyAgICAgICByYW5kb21uZXNzOiByYW5kb21uZXNzLAoJLy8gICAgIH0pCglieXRlIDB4MmYwNjQ2OTEgLy8gQ29tcGxldGVHYW1lRXZlbnQoYWRkcmVzcyx1aW50NjQsdWludDY0LGJ5dGVbXSkKCWJ5dGUgMHggLy8gaW5pdGlhbCBoZWFkCglieXRlIDB4IC8vIGluaXRpYWwgdGFpbAoJYnl0ZSAweDAwMzIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpbnQgMAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgNiAvLyB3b246IHVpbnQ2NAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDIgLy8gcmFuZG9tbmVzczogYnl0ZXMKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoKCS8vIGNvbnRyYWN0cy9Db2luRmxpcC5hbGdvLnRzOjQwMwoJLy8gdGhpcy5kZWxldGVHYW1lKGFkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJY2FsbHN1YiBkZWxldGVHYW1lCglyZXRzdWIKCipjcmVhdGVfTm9PcDoKCW1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oc3RyaW5nLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCW1ldGhvZCAic2V0TWFuYWdlcihhZGRyZXNzKXZvaWQiCgltZXRob2QgImdldE1hbmFnZXIoKWFkZHJlc3MiCgltZXRob2QgImJvb3RzdHJhcCgpdm9pZCIKCW1ldGhvZCAiZ2V0RmVlcygpdm9pZCIKCW1ldGhvZCAiYWRkUHJpemVQb29sKGF4ZmVyKXZvaWQiCgltZXRob2QgImNyZWF0ZUdhbWUoYXhmZXIscGF5LHVpbnQ2NCl1aW50NjQiCgltZXRob2QgImNhbmNlbEdhbWUoYWRkcmVzcyl2b2lkIgoJbWV0aG9kICJjb21wbGV0ZUdhbWUoYWRkcmVzcyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9zZXRNYW5hZ2VyICphYmlfcm91dGVfZ2V0TWFuYWdlciAqYWJpX3JvdXRlX2Jvb3RzdHJhcCAqYWJpX3JvdXRlX2dldEZlZXMgKmFiaV9yb3V0ZV9hZGRQcml6ZVBvb2wgKmFiaV9yb3V0ZV9jcmVhdGVHYW1lICphYmlfcm91dGVfY2FuY2VsR2FtZSAqYWJpX3JvdXRlX2NvbXBsZXRlR2FtZQoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycgoKKmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgltZXRob2QgInVwZGF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIFVwZGF0ZUFwcGxpY2F0aW9uCgllcnIKCipjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uOgoJbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBEZWxldGVBcHBsaWNhdGlvbgoJZXJyCgoqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50Cgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1YgoKKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0Cgljb25jYXQKCWZyYW1lX2J1cnkgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWR1cAoJbGVuCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWJ0b2kKCSsKCWl0b2IKCWV4dHJhY3QgNiAyCglmcmFtZV9idXJ5IC0yIC8vIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJc3dhcAoJY29uY2F0CglmcmFtZV9idXJ5IC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWI=",
    clear: "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  contract: {
    name: "CoinFlip",
    desc: "",
    methods: [
      {
        name: "setManager",
        desc: "Changes which address can manage this contract",
        args: [
          {
            name: "newManager",
            type: "address",
            desc: "the Address that will be able to manage the contract",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "SetManagerEvent",
            args: [
              {
                name: "oldManager",
                type: "address",
              },
              {
                name: "newManager",
                type: "address",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "getManager",
        desc: "Returns the current manager",
        readonly: true,
        args: [],
        returns: {
          type: "address",
          desc: "The current managers Address",
        },
      },
      {
        name: "createApplication",
        args: [
          {
            name: "name",
            type: "string",
          },
          {
            name: "assetId",
            type: "uint64",
          },
          {
            name: "beaconAppId",
            type: "uint64",
          },
          {
            name: "feePercent",
            type: "uint64",
          },
          {
            name: "minBet",
            type: "uint64",
          },
          {
            name: "maxBet",
            type: "uint64",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "CreateEvent",
            args: [
              {
                name: "name",
                type: "string",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "updateApplication",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "deleteApplication",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "bootstrap",
        desc: "Initialiase the app after creation",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "getFees",
        desc: "Allows manager to claim the fees",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "addPrizePool",
        desc: "Allows prize pool to be added, callable by anyone",
        args: [
          {
            name: "axfer",
            type: "axfer",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "AddPrizePoolEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "amount",
                type: "uint64",
              },
              {
                name: "total",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "createGame",
        desc: "Creates a new game for the caller",
        args: [
          {
            name: "axfer",
            type: "axfer",
          },
          {
            name: "boxFeeTxn",
            type: "pay",
          },
          {
            name: "heads",
            type: "uint64",
          },
        ],
        returns: {
          type: "uint64",
        },
        events: [
          {
            name: "CreateGameEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "wager",
                type: "uint64",
              },
              {
                name: "commitmentRound",
                type: "uint64",
              },
              {
                name: "heads",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "cancelGame",
        desc: "Allows user to cancel the game and request a refund (should be callable by admin)",
        args: [
          {
            name: "address",
            type: "address",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "CancelGameEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "wager",
                type: "uint64",
              },
            ],
            desc: "",
          },
        ],
      },
      {
        name: "completeGame",
        desc: "Completes a game by calling the beacon, determining the result and paying out the user",
        args: [
          {
            name: "address",
            type: "address",
          },
        ],
        returns: {
          type: "void",
        },
        events: [
          {
            name: "CompleteGameEvent",
            args: [
              {
                name: "address",
                type: "address",
              },
              {
                name: "wager",
                type: "uint64",
              },
              {
                name: "won",
                type: "uint64",
              },
              {
                name: "randomness",
                type: "byte[]",
              },
            ],
            desc: "",
          },
        ],
      },
    ],
    events: [
      {
        name: "SetManagerEvent",
        args: [
          {
            name: "oldManager",
            type: "address",
          },
          {
            name: "newManager",
            type: "address",
          },
        ],
        desc: "",
      },
      {
        name: "CreateEvent",
        args: [
          {
            name: "name",
            type: "string",
          },
        ],
        desc: "",
      },
      {
        name: "AddPrizePoolEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "amount",
            type: "uint64",
          },
          {
            name: "total",
            type: "uint64",
          },
        ],
        desc: "",
      },
      {
        name: "CreateGameEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "wager",
            type: "uint64",
          },
          {
            name: "commitmentRound",
            type: "uint64",
          },
          {
            name: "heads",
            type: "uint64",
          },
        ],
        desc: "",
      },
      {
        name: "CancelGameEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "wager",
            type: "uint64",
          },
        ],
        desc: "",
      },
      {
        name: "CompleteGameEvent",
        args: [
          {
            name: "address",
            type: "address",
          },
          {
            name: "wager",
            type: "uint64",
          },
          {
            name: "won",
            type: "uint64",
          },
          {
            name: "randomness",
            type: "byte[]",
          },
        ],
        desc: "",
      },
    ],
  },
};

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp = {
  onCompleteAction?: "no_op" | OnApplicationComplete.NoOpOC;
};
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn = {
  onCompleteAction: "opt_in" | OnApplicationComplete.OptInOC;
};
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut = {
  onCompleteAction: "close_out" | OnApplicationComplete.CloseOutOC;
};
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp = {
  onCompleteAction:
    | "delete_application"
    | OnApplicationComplete.DeleteApplicationOC;
};
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp = {
  onCompleteAction:
    | "update_application"
    | OnApplicationComplete.UpdateApplicationOC;
};
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint;
  /**
   * Gets the state value as a number.
   */
  asNumber(): number;
};
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array;
  /**
   * Gets the state value as a string
   */
  asString(): string;
};

export type AppCreateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult> &
  AppReference;
export type AppUpdateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult>;

export type AppClientComposeCallCoreParams = Omit<
  AppClientCallCoreParams,
  "sendParams"
> & {
  sendParams?: Omit<
    SendTransactionParams,
    | "skipSending"
    | "atc"
    | "skipWaiting"
    | "maxRoundsToWaitForConfirmation"
    | "populateAppCallResources"
  >;
};
export type AppClientComposeExecuteParams = Pick<
  SendTransactionParams,
  | "skipWaiting"
  | "maxRoundsToWaitForConfirmation"
  | "populateAppCallResources"
  | "suppressLog"
>;

/**
 * Defines the types of available calls and state of the CoinFlip smart contract.
 */
export type CoinFlip = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    "setManager(address)void" | "setManager",
    {
      argsObj: {
        /**
         * the Address that will be able to manage the contract
         */
        newManager: string;
      };
      argsTuple: [newManager: string];
      returns: void;
    }
  > &
    Record<
      "getManager()address" | "getManager",
      {
        argsObj: {};
        argsTuple: [];
        /**
         * The current managers Address
         */
        returns: string;
      }
    > &
    Record<
      | "createApplication(string,uint64,uint64,uint64,uint64,uint64)void"
      | "createApplication",
      {
        argsObj: {
          name: string;
          assetId: bigint | number;
          beaconAppId: bigint | number;
          feePercent: bigint | number;
          minBet: bigint | number;
          maxBet: bigint | number;
        };
        argsTuple: [
          name: string,
          assetId: bigint | number,
          beaconAppId: bigint | number,
          feePercent: bigint | number,
          minBet: bigint | number,
          maxBet: bigint | number
        ];
        returns: void;
      }
    > &
    Record<
      "updateApplication()void" | "updateApplication",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "deleteApplication()void" | "deleteApplication",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "bootstrap()void" | "bootstrap",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "getFees()void" | "getFees",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "addPrizePool(axfer)void" | "addPrizePool",
      {
        argsObj: {
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>;
        };
        argsTuple: [
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>
        ];
        returns: void;
      }
    > &
    Record<
      "createGame(axfer,pay,uint64)uint64" | "createGame",
      {
        argsObj: {
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>;
          boxFeeTxn:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>;
          heads: bigint | number;
        };
        argsTuple: [
          axfer:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>,
          boxFeeTxn:
            | TransactionToSign
            | Transaction
            | Promise<SendTransactionResult>,
          heads: bigint | number
        ];
        returns: bigint;
      }
    > &
    Record<
      "cancelGame(address)void" | "cancelGame",
      {
        argsObj: {
          address: string;
        };
        argsTuple: [address: string];
        returns: void;
      }
    > &
    Record<
      "completeGame(address)void" | "completeGame",
      {
        argsObj: {
          address: string;
        };
        argsTuple: [address: string];
        returns: void;
      }
    >;
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      manager?: BinaryState;
      name?: BinaryState;
      assetId?: IntegerState;
      beaconAppId?: IntegerState;
      feePercent?: IntegerState;
      minBet?: IntegerState;
      maxBet?: IntegerState;
      fees?: IntegerState;
      prizePool?: IntegerState;
      totalGames?: IntegerState;
      totalCancelled?: IntegerState;
      totalHeads?: IntegerState;
      totalWagered?: IntegerState;
      totalWon?: IntegerState;
    };
  };
};
/**
 * Defines the possible abi call signatures
 */
export type CoinFlipSig = keyof CoinFlip["methods"];
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends CoinFlipSig | undefined> = {
  method: TSignature;
  methodArgs: TSignature extends undefined
    ? undefined
    : Array<ABIAppCallArg | undefined>;
} & AppClientCallCoreParams &
  CoreAppCallArgs;
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>;
/**
 * Maps a method signature from the CoinFlip smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends CoinFlipSig> =
  CoinFlip["methods"][TSignature]["argsObj" | "argsTuple"];
/**
 * Maps a method signature from the CoinFlip smart contract to the method's return type
 */
export type MethodReturn<TSignature extends CoinFlipSig> =
  CoinFlip["methods"][TSignature]["returns"];

/**
 * A factory for available 'create' calls
 */
export type CoinFlipCreateCalls = (typeof CoinFlipCallFactory)["create"];
/**
 * Defines supported create methods for this smart contract
 */
export type CoinFlipCreateCallParams =
  TypedCallParams<"createApplication(string,uint64,uint64,uint64,uint64,uint64)void"> &
    OnCompleteNoOp;
/**
 * A factory for available 'update' calls
 */
export type CoinFlipUpdateCalls = (typeof CoinFlipCallFactory)["update"];
/**
 * Defines supported update methods for this smart contract
 */
export type CoinFlipUpdateCallParams =
  TypedCallParams<"updateApplication()void">;
/**
 * A factory for available 'delete' calls
 */
export type CoinFlipDeleteCalls = (typeof CoinFlipCallFactory)["delete"];
/**
 * Defines supported delete methods for this smart contract
 */
export type CoinFlipDeleteCallParams =
  TypedCallParams<"deleteApplication()void">;
/**
 * Defines arguments required for the deploy method.
 */
export type CoinFlipDeployArgs = {
  deployTimeParams?: TealTemplateParams;
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: CoinFlipCreateCalls) => CoinFlipCreateCallParams;
  /**
   * A delegate which takes a update call factory and returns the update call params for this smart contract
   */
  updateCall?: (callFactory: CoinFlipUpdateCalls) => CoinFlipUpdateCallParams;
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: CoinFlipDeleteCalls) => CoinFlipDeleteCallParams;
};

/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class CoinFlipCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the CoinFlip smart contract using the createApplication(string,uint64,uint64,uint64,uint64,uint64)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(
        args: MethodArgs<"createApplication(string,uint64,uint64,uint64,uint64,uint64)void">,
        params: AppClientCallCoreParams &
          CoreAppCallArgs &
          AppClientCompilationParams &
          OnCompleteNoOp = {}
      ) {
        return {
          method:
            "createApplication(string,uint64,uint64,uint64,uint64,uint64)void" as const,
          methodArgs: Array.isArray(args)
            ? args
            : [
                args.name,
                args.assetId,
                args.beaconAppId,
                args.feePercent,
                args.minBet,
                args.maxBet,
              ],
          ...params,
        };
      },
    };
  }

  /**
   * Gets available update call factories
   */
  static get update() {
    return {
      /**
       * Constructs an update call for the CoinFlip smart contract using the updateApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      updateApplication(
        args: MethodArgs<"updateApplication()void">,
        params: AppClientCallCoreParams &
          CoreAppCallArgs &
          AppClientCompilationParams = {}
      ) {
        return {
          method: "updateApplication()void" as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the CoinFlip smart contract using the deleteApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams & CoreAppCallArgs = {}
      ) {
        return {
          method: "deleteApplication()void" as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Constructs a no op call for the setManager(address)void ABI method
   *
   * Changes which address can manage this contract
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setManager(
    args: MethodArgs<"setManager(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "setManager(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.newManager],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getManager()address ABI method
   *
   * Returns the current manager
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getManager(
    args: MethodArgs<"getManager()address">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getManager()address" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the bootstrap()void ABI method
   *
   * Initialiase the app after creation
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "bootstrap()void" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the getFees()void ABI method
   *
   * Allows manager to claim the fees
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getFees(
    args: MethodArgs<"getFees()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "getFees()void" as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the addPrizePool(axfer)void ABI method
   *
   * Allows prize pool to be added, callable by anyone
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "addPrizePool(axfer)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.axfer],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the createGame(axfer,pay,uint64)uint64 ABI method
   *
   * Creates a new game for the caller
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createGame(
    args: MethodArgs<"createGame(axfer,pay,uint64)uint64">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "createGame(axfer,pay,uint64)uint64" as const,
      methodArgs: Array.isArray(args)
        ? args
        : [args.axfer, args.boxFeeTxn, args.heads],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the cancelGame(address)void ABI method
   *
   * Allows user to cancel the game and request a refund (should be callable by admin)
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static cancelGame(
    args: MethodArgs<"cancelGame(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "cancelGame(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the completeGame(address)void ABI method
   *
   * Completes a game by calling the beacon, determining the result and paying out the user
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static completeGame(
    args: MethodArgs<"completeGame(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs
  ) {
    return {
      method: "completeGame(address)void" as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    };
  }
}

/**
 * A client to make calls to the CoinFlip smart contract
 */
export class CoinFlipClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient;

  private readonly sender: SendTransactionFrom | undefined;

  /**
   * Creates a new instance of `CoinFlipClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender;
    this.appClient = algokit.getAppClient(
      {
        ...appDetails,
        app: APP_SPEC,
      },
      algod
    );
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<
    TReturn,
    TResult extends AppCallTransactionResult = AppCallTransactionResult
  >(
    result: AppCallTransactionResult,
    returnValueFormatter?: (value: any) => TReturn
  ): AppCallTransactionResultOfType<TReturn> & TResult {
    if (result.return?.decodeError) {
      throw result.return.decodeError;
    }
    const returnValue =
      result.return?.returnValue !== undefined &&
      returnValueFormatter !== undefined
        ? returnValueFormatter(result.return.returnValue)
        : (result.return?.returnValue as TReturn | undefined);
    return {
      ...result,
      return: returnValue,
    } as AppCallTransactionResultOfType<TReturn> & TResult;
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof CoinFlip["methods"]>(
    typedCallParams: TypedCallParams<TSignature>,
    returnValueFormatter?: (value: any) => MethodReturn<TSignature>
  ) {
    return this.mapReturnValue<MethodReturn<TSignature>>(
      await this.appClient.call(typedCallParams),
      returnValueFormatter
    );
  }

  /**
   * Idempotently deploys the CoinFlip smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(
    params: CoinFlipDeployArgs & AppClientDeployCoreParams = {}
  ): ReturnType<ApplicationClient["deploy"]> {
    const createArgs = params.createCall?.(CoinFlipCallFactory.create);
    const updateArgs = params.updateCall?.(CoinFlipCallFactory.update);
    const deleteArgs = params.deleteCall?.(CoinFlipCallFactory.delete);
    return this.appClient.deploy({
      ...params,
      updateArgs,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    });
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this;
    return {
      /**
       * Creates a new instance of the CoinFlip smart contract using the createApplication(string,uint64,uint64,uint64,uint64,uint64)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(
        args: MethodArgs<"createApplication(string,uint64,uint64,uint64,uint64,uint64)void">,
        params: AppClientCallCoreParams &
          AppClientCompilationParams &
          OnCompleteNoOp = {}
      ) {
        return $this.mapReturnValue<
          MethodReturn<"createApplication(string,uint64,uint64,uint64,uint64,uint64)void">,
          AppCreateCallTransactionResult
        >(
          await $this.appClient.create(
            CoinFlipCallFactory.create.createApplication(args, params)
          )
        );
      },
    };
  }

  /**
   * Gets available update methods
   */
  public get update() {
    const $this = this;
    return {
      /**
       * Updates an existing instance of the CoinFlip smart contract using the updateApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The update result
       */
      async updateApplication(
        args: MethodArgs<"updateApplication()void">,
        params: AppClientCallCoreParams & AppClientCompilationParams = {}
      ) {
        return $this.mapReturnValue<
          MethodReturn<"updateApplication()void">,
          AppUpdateCallTransactionResult
        >(
          await $this.appClient.update(
            CoinFlipCallFactory.update.updateApplication(args, params)
          )
        );
      },
    };
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this;
    return {
      /**
       * Deletes an existing instance of the CoinFlip smart contract using the deleteApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams = {}
      ) {
        return $this.mapReturnValue<MethodReturn<"deleteApplication()void">>(
          await $this.appClient.delete(
            CoinFlipCallFactory.delete.deleteApplication(args, params)
          )
        );
      },
    };
  }

  /**
   * Makes a clear_state call to an existing instance of the CoinFlip smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(
    args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.appClient.clearState(args);
  }

  /**
   * Calls the setManager(address)void ABI method.
   *
   * Changes which address can manage this contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setManager(
    args: MethodArgs<"setManager(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.setManager(args, params));
  }

  /**
   * Calls the getManager()address ABI method.
   *
   * Returns the current manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: The current managers Address
   */
  public getManager(
    args: MethodArgs<"getManager()address">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.getManager(args, params));
  }

  /**
   * Calls the bootstrap()void ABI method.
   *
   * Initialiase the app after creation
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.bootstrap(args, params));
  }

  /**
   * Calls the getFees()void ABI method.
   *
   * Allows manager to claim the fees
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getFees(
    args: MethodArgs<"getFees()void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.getFees(args, params));
  }

  /**
   * Calls the addPrizePool(axfer)void ABI method.
   *
   * Allows prize pool to be added, callable by anyone
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.addPrizePool(args, params));
  }

  /**
   * Calls the createGame(axfer,pay,uint64)uint64 ABI method.
   *
   * Creates a new game for the caller
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public createGame(
    args: MethodArgs<"createGame(axfer,pay,uint64)uint64">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.createGame(args, params));
  }

  /**
   * Calls the cancelGame(address)void ABI method.
   *
   * Allows user to cancel the game and request a refund (should be callable by admin)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public cancelGame(
    args: MethodArgs<"cancelGame(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.cancelGame(args, params));
  }

  /**
   * Calls the completeGame(address)void ABI method.
   *
   * Completes a game by calling the beacon, determining the result and paying out the user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public completeGame(
    args: MethodArgs<"completeGame(address)void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {}
  ) {
    return this.call(CoinFlipCallFactory.completeGame(args, params));
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(
    state: AppState,
    key: string
  ): BinaryState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if (!("valueRaw" in value))
      throw new Error(
        `Failed to parse state value for ${key}; received an int when expected a byte array`
      );
    return {
      asString(): string {
        return value.value;
      },
      asByteArray(): Uint8Array {
        return value.valueRaw;
      },
    };
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(
    state: AppState,
    key: string
  ): IntegerState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if ("valueRaw" in value)
      throw new Error(
        `Failed to parse state value for ${key}; received a byte array when expected a number`
      );
    return {
      asBigInt() {
        return typeof value.value === "bigint"
          ? value.value
          : BigInt(value.value);
      },
      asNumber(): number {
        return typeof value.value === "bigint"
          ? Number(value.value)
          : value.value;
      },
    };
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<CoinFlip["state"]["global"]> {
    const state = await this.appClient.getGlobalState();
    return {
      get manager() {
        return CoinFlipClient.getBinaryState(state, "manager");
      },
      get name() {
        return CoinFlipClient.getBinaryState(state, "name");
      },
      get assetId() {
        return CoinFlipClient.getIntegerState(state, "assetId");
      },
      get beaconAppId() {
        return CoinFlipClient.getIntegerState(state, "beaconAppId");
      },
      get feePercent() {
        return CoinFlipClient.getIntegerState(state, "feePercent");
      },
      get minBet() {
        return CoinFlipClient.getIntegerState(state, "minBet");
      },
      get maxBet() {
        return CoinFlipClient.getIntegerState(state, "maxBet");
      },
      get fees() {
        return CoinFlipClient.getIntegerState(state, "fees");
      },
      get prizePool() {
        return CoinFlipClient.getIntegerState(state, "prizePool");
      },
      get totalGames() {
        return CoinFlipClient.getIntegerState(state, "totalGames");
      },
      get totalCancelled() {
        return CoinFlipClient.getIntegerState(state, "totalCancelled");
      },
      get totalHeads() {
        return CoinFlipClient.getIntegerState(state, "totalHeads");
      },
      get totalWagered() {
        return CoinFlipClient.getIntegerState(state, "totalWagered");
      },
      get totalWon() {
        return CoinFlipClient.getIntegerState(state, "totalWon");
      },
    };
  }

  public compose(): CoinFlipComposer {
    const client = this;
    const atc = new AtomicTransactionComposer();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: any) => any)> = [];
    return {
      setManager(
        args: MethodArgs<"setManager(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.setManager(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getManager(
        args: MethodArgs<"getManager()address">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getManager(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      bootstrap(
        args: MethodArgs<"bootstrap()void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.bootstrap(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      getFees(
        args: MethodArgs<"getFees()void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.getFees(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      addPrizePool(
        args: MethodArgs<"addPrizePool(axfer)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.addPrizePool(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      createGame(
        args: MethodArgs<"createGame(axfer,pay,uint64)uint64">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.createGame(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      cancelGame(
        args: MethodArgs<"cancelGame(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.cancelGame(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      completeGame(
        args: MethodArgs<"completeGame(address)void">,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.completeGame(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      get update() {
        const $this = this;
        return {
          updateApplication(
            args: MethodArgs<"updateApplication()void">,
            params?: AppClientComposeCallCoreParams & AppClientCompilationParams
          ) {
            promiseChain = promiseChain.then(() =>
              client.update.updateApplication(args, {
                ...params,
                sendParams: { ...params?.sendParams, skipSending: true, atc },
              })
            );
            resultMappers.push(undefined);
            return $this;
          },
        };
      },
      get delete() {
        const $this = this;
        return {
          deleteApplication(
            args: MethodArgs<"deleteApplication()void">,
            params?: AppClientComposeCallCoreParams
          ) {
            promiseChain = promiseChain.then(() =>
              client.delete.deleteApplication(args, {
                ...params,
                sendParams: { ...params?.sendParams, skipSending: true, atc },
              })
            );
            resultMappers.push(undefined);
            return $this;
          },
        };
      },
      clearState(
        args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs
      ) {
        promiseChain = promiseChain.then(() =>
          client.clearState({
            ...args,
            sendParams: { ...args?.sendParams, skipSending: true, atc },
          })
        );
        resultMappers.push(undefined);
        return this;
      },
      addTransaction(
        txn:
          | TransactionWithSigner
          | TransactionToSign
          | Transaction
          | Promise<SendTransactionResult>,
        defaultSender?: SendTransactionFrom
      ) {
        promiseChain = promiseChain.then(async () =>
          atc.addTransaction(
            await algokit.getTransactionWithSigner(
              txn,
              defaultSender ?? client.sender
            )
          )
        );
        return this;
      },
      async atc() {
        await promiseChain;
        return atc;
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain;
        const result = await atc.simulate(
          client.algod,
          new modelsv2.SimulateRequest({ txnGroups: [], ...options })
        );
        return {
          ...result,
          returns: result.methodResults?.map((val, i) =>
            resultMappers[i] !== undefined
              ? resultMappers[i]!(val.returnValue)
              : val.returnValue
          ),
        };
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain;
        const result = await algokit.sendAtomicTransactionComposer(
          { atc, sendParams },
          client.algod
        );
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined
              ? resultMappers[i]!(val.returnValue)
              : val.returnValue
          ),
        };
      },
    } as unknown as CoinFlipComposer;
  }
}
export type CoinFlipComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the setManager(address)void ABI method.
   *
   * Changes which address can manage this contract
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setManager(
    args: MethodArgs<"setManager(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"setManager(address)void">]>;

  /**
   * Calls the getManager()address ABI method.
   *
   * Returns the current manager
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getManager(
    args: MethodArgs<"getManager()address">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"getManager()address">]>;

  /**
   * Calls the bootstrap()void ABI method.
   *
   * Initialiase the app after creation
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  bootstrap(
    args: MethodArgs<"bootstrap()void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"bootstrap()void">]>;

  /**
   * Calls the getFees()void ABI method.
   *
   * Allows manager to claim the fees
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getFees(
    args: MethodArgs<"getFees()void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"getFees()void">]>;

  /**
   * Calls the addPrizePool(axfer)void ABI method.
   *
   * Allows prize pool to be added, callable by anyone
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPrizePool(
    args: MethodArgs<"addPrizePool(axfer)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"addPrizePool(axfer)void">]>;

  /**
   * Calls the createGame(axfer,pay,uint64)uint64 ABI method.
   *
   * Creates a new game for the caller
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createGame(
    args: MethodArgs<"createGame(axfer,pay,uint64)uint64">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<
    [...TReturns, MethodReturn<"createGame(axfer,pay,uint64)uint64">]
  >;

  /**
   * Calls the cancelGame(address)void ABI method.
   *
   * Allows user to cancel the game and request a refund (should be callable by admin)
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  cancelGame(
    args: MethodArgs<"cancelGame(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"cancelGame(address)void">]>;

  /**
   * Calls the completeGame(address)void ABI method.
   *
   * Completes a game by calling the beacon, determining the result and paying out the user
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  completeGame(
    args: MethodArgs<"completeGame(address)void">,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, MethodReturn<"completeGame(address)void">]>;

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the CoinFlip smart contract using the updateApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateApplication(
      args: MethodArgs<"updateApplication()void">,
      params?: AppClientComposeCallCoreParams & AppClientCompilationParams
    ): CoinFlipComposer<[...TReturns, MethodReturn<"updateApplication()void">]>;
  };

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the CoinFlip smart contract using the deleteApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteApplication(
      args: MethodArgs<"deleteApplication()void">,
      params?: AppClientComposeCallCoreParams
    ): CoinFlipComposer<[...TReturns, MethodReturn<"deleteApplication()void">]>;
  };

  /**
   * Makes a clear_state call to an existing instance of the CoinFlip smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(
    args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs
  ): CoinFlipComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(
    txn:
      | TransactionWithSigner
      | TransactionToSign
      | Transaction
      | Promise<SendTransactionResult>,
    defaultSender?: SendTransactionFrom
  ): CoinFlipComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(
    options?: SimulateOptions
  ): Promise<CoinFlipComposerSimulateResult<TReturns>>;
  /**
   * Executes the transaction group and returns the results
   */
  execute(
    sendParams?: AppClientComposeExecuteParams
  ): Promise<CoinFlipComposerResults<TReturns>>;
};
export type SimulateOptions = Omit<
  ConstructorParameters<typeof modelsv2.SimulateRequest>[0],
  "txnGroups"
>;
export type CoinFlipComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns;
  methodResults: ABIResult[];
  simulateResponse: modelsv2.SimulateResponse;
};
export type CoinFlipComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns;
  groupId: string;
  txIds: string[];
  transactions: Transaction[];
};
